<!DOCTYPE HTML>
<html>
<head>
<title>MicroProfile Capture</title>
<style>
/* about css: http://bit.ly/1eMQ42U */
body {margin: 0px;padding: 0px; font: 12px Courier New;background-color:#474747; color:white;overflow:hidden;}
ul {list-style-type: none;margin: 0;padding: 0;}
li{display: inline; float:left;border:5px; position:relative;text-align:center;}
a {
    float:left;
    text-decoration:none;
    display: inline;
    text-align: center;
	padding:5px;
	padding-bottom:0px;
	padding-top:0px;
    color: #FFFFFF;
    background-color: #474747;
}
a:hover, a:active{
	background-color: #000000;
}

ul ul {
    position:absolute;
    left:0;
    top:100%;
    margin-left:-999em;
}
li:hover ul {
    margin-left:0;
    margin-right:0;
}
ul li ul{ display:block;float:none;width:100%;}
ul li ul li{ display:block;float:none;width:100%;}
li li a{ display:block;float:none;width:100%;text-align:left;}
#nav li:hover div {margin-left:0;}
.help {position:absolute;z-index:5;text-align:left;padding:2px;margin-left:-999em;background-color: #313131;width:300px;}
.helpstart {position:absolute;z-index:5;text-align:left;padding:2px;background-color: #313131;width:300px;display:none}
.root {z-index:1;position:absolute;top:0px;left:0px;}
.filterinput0{position:fixed;bottom:10px;left:25px;background-color: #313131}
.filterinput1{position:fixed;bottom:10px;left:175px;background-color: #313131}
</style>
</head>
<body style="">
<div id='filterinput'>
<div class="filterinput0">Group<br><input type="text" id="filtergroup"></div>
<div class="filterinput1">Timer/Thread<br><input type="text" id="filtertimer"></div>
</div>
<canvas id="DetailedView" height="100%" style="background-color:#474747;margin:0px;padding:0px;"></canvas>
<script>



//todo
// on demand redraw
// selection
// base graph
//connection status window
// log window 
// menu item


var FRAME_HISTORY_COLOR_CPU = '#ff7f27';
var FRAME_HISTORY_COLOR_GPU = '#ffffff';



var CanvasDetailedView = document.getElementById('DetailedView');
var CanvasDetailedOffscreen = document.createElement('canvas');

var CanvasArray0 = [];
var CanvasArray1 = [];
var Views = [];

var nWidth = CanvasDetailedView.width;
var nHeight = CanvasDetailedView.height;
var nBackColors = ['#474747', '#313131' ];
var nBackColorOffset = '#606060';
var FontHeight = 10;
var FontWidth = 1;
var FontAscent = 3; //Set manually
var Font = 'Bold ' + FontHeight + 'px Courier New';
var FontFlash = 'Bold ' + 35 + 'px Courier New';
var BoxHeight = FontHeight + 2;
var MouseX = 0;
var MouseY = 0;
var MouseReleased = false;

var ReferenceTime = 33.0;

var ProfileMode = 0;
var ProfileRedraw0 = 0;
var ProfileRedraw1 = 0;
var ProfileRedraw2 = 0;
var ProfileFps = 0;
var ProfileFpsAggr = 0;
var ProfileFpsCount = 0;
var ProfileLastTimeStamp = new Date();
var PlotfArray = new Array();

var FrameData = {};
var FrameCount = 256;
var FrameOffset = 0;

var WSConnected = 0;
var WSSeconds = 0;
var WSFail = 0;
var WS;
var WSPort = 1337;
var WSPath;
var WSMsgTimerTree = 1; //MSG_TIMER_TREE
var WSMsgEnabled = 2; // MSG_ENABLED
var WSMsgFrame = 3; // MSG_FRAME
var WSSend = 0;
var WSReceive = 0;
var WSSendBytes = 0;
var WSReceiveBytes = 0;
var WSOpenTime = 0;


var TimerArray = [];
var Empty = {"id":0};

TimerArray.push(Empty); // 0 is root of tree



function Plotf(str)
{
	PlotfArray.push(str)
}
function PlotfClear()
{
	PlotfArray = new Array();
}

function ProfileModeClear()
{
	if(ProfileMode)
	{
		ProfileData = new Object();
		ProfileStackTime = new Array();
		ProfileStackName = new Array();
	}
}
function ProfileEnter(Name)
{
	if(ProfileMode)
	{
		ProfileStackTime.push(new Date());
		ProfileStackName.push(Name);
	}
}
function ProfileLeave()
{
	if(ProfileMode)
	{
		var Time = new Date();
		var Delta = Time - ProfileStackTime.pop();
		var Name = ProfileStackName.pop();
		var Obj = ProfileData[Name];
		if(!Obj)
		{
			Obj = new Object();
			Obj.Count = 0;
			Obj.Name = Name;
			Obj.Time = 0;
			ProfileData[Name] = Obj;
		}
		Obj.Time += Delta;
		Obj.Count += 1;
	}
}

function ProfilePlot(s)
{
	if(ProfileMode)
	{
		var A = ProfileData.Plot;
		if(!A)
		{
			ProfileData.Plot = Array();
			A = ProfileData.Plot;
		}
		if(A.length<10)
		{
			A.push(s);
		}
	}
}
function ProfileModeDump()
{
	for(var idx in ProfileData)
	{
		var Timer = ProfileData[idx];
		console.log(Timer.Name + " " + Timer.Time + "ms " + Timer.Count);
	}

}
function ProfileModeDraw(Canvas)
{
	if(ProfileMode)
	{
		var StringArray = [];
		for(var idx in ProfileData)
		{
			if(idx == "Plot")
				continue;
			var Timer = ProfileData[idx];
			StringArray.push(Timer.Name);
			StringArray.push(Timer.Time + "ms");
			StringArray.push("#");
			StringArray.push("" + Timer.Count);
		}
		// StringArray.push("debug");
		// StringArray.push(Debug);
		var Time = new Date();
		var Delta = Time - ProfileLastTimeStamp;
		ProfileLastTimeStamp = Time;
		StringArray.push("Frame Delta");
		StringArray.push(Delta + "ms");
		if(ProfileMode == 2)
		{
			ProfileFpsAggr += Delta;
			ProfileFpsCount ++ ;
			var AggrFrames = 10;
			if(ProfileFpsCount == AggrFrames)
			{
				ProfileFps = 1000 / (ProfileFpsAggr / AggrFrames);
				ProfileFpsAggr = 0;
				ProfileFpsCount = 0;
			}
			StringArray.push("FPS");
			StringArray.push("" + ProfileFps.toFixed(2));
		}
		StringArray.push("ProfileRedraw0");
		StringArray.push("" + ProfileRedraw0);
		StringArray.push("ProfileRedraw1");
		StringArray.push("" + ProfileRedraw1);
		StringArray.push("ProfileRedraw2");
		StringArray.push("" + ProfileRedraw2);
		ProfileRedraw0 = 0;
		ProfileRedraw1 = 0;
		ProfileRedraw2 = 0;


		for(var i = 0; i < ProfileData.Plot; ++i)
		{
			StringArray.push("");
			StringArray.push(ProfileData.Plot[i]);
		}
		ProfileData.Plot = Array();
		DrawToolTip(StringArray, Canvas, 0, 200);
	}
}



function MeasureFont()
{
	var context = CanvasDetailedView.getContext('2d');
	//context.font = Font;
	FontWidth = context.measureText('W').width;

}
function ResizeCanvasDPR(w, h, c)
{
	DPR = window.devicePixelRatio;
	if(DPR)
	{
		c.style.width = w + 'px'; 
		c.style.height = h + 'px';
		c.width = w * DPR;
		c.height = h * DPR;
		c.getContext('2d').scale(DPR,DPR);
	}
	else
	{
		c.width = w;
		c.height = h;
	}

}

function ResizeCanvasDPR2(w, h, c)
{
	DPR = window.devicePixelRatio;
	if(DPR)
	{
		c.style.width = w + 'px'; 
		c.style.height = h + 'px';
		c.width = w * DPR;
		c.height = h * DPR;
		c.getContext('2d').scale(DPR,DPR);
	}
	else
	{
		c.width = w;
		c.height = h;
	}

}
function CreateView(x, y, w, h, name, DisplayFunc)
{
	var idx = Views.length;
	var c0 = CanvasArray0[idx];
	var c1 = CanvasArray1[idx];
	if(!c0)
	{
		c0 = document.createElement('canvas');
		CanvasArray0[idx] = c0;
	}
	if(!c1)
	{
		c1 = document.createElement('canvas');
		CanvasArray1[idx] = c1;
	}
	var View = {};
	View.x = x;
	View.y = y;
	View.w = w;
	View.h = h;
	View.Canvas = [c0, c1];
	View.OffscreenData = [null, null];
	ResizeCanvasDPR(w, h, c0);
	ResizeCanvasDPR(w, h, c1);

	c0.getContext('2d').clearRect(0, 0, w, h);
	c1.getContext('2d').clearRect(0, 0, w, h);
	View.OffscreenData[0] = c0.getContext('2d').getImageData(0, 0, c0.width, c0.height);
	View.OffscreenData[1] = c1.getContext('2d').getImageData(0, 0, c1.width, c1.height);
	View.BackBuffer = 0;
	View.DisplayFunc = DisplayFunc;
	return View;
}

function CreateViews(Width, Height)
{
	Views = [];
	var History = CreateView(0, 0, Width, 100, "History", DrawHistory);
	Views.push(History);
}

function ResizeCanvas() 
{
	nWidth = window.innerWidth;
	nHeight = window.innerHeight;
	DPR = window.devicePixelRatio;
	ResizeCanvasDPR(nWidth, nHeight, CanvasDetailedView);
	ResizeCanvasDPR(nWidth, nHeight, CanvasDetailedOffscreen);

	if(DPR)
	{
		CanvasDetailedView.style.width = nWidth + 'px'; 
		CanvasDetailedView.style.height = nHeight + 'px';
		CanvasDetailedView.width = nWidth * DPR;
		CanvasDetailedView.height = nHeight * DPR;
		CanvasDetailedView.getContext('2d').scale(DPR,DPR);

		CanvasDetailedOffscreen.style.width = nWidth + 'px';
		CanvasDetailedOffscreen.style.height = nHeight + 'px';
		CanvasDetailedOffscreen.width = nWidth * DPR;
		CanvasDetailedOffscreen.height = nHeight * DPR;
		CanvasDetailedOffscreen.getContext('2d').scale(DPR,DPR);

	}
	else
	{
		DPR = 1;
		CanvasDetailedView.width = nWidth;
		CanvasDetailedView.height = nHeight;
		CanvasDetailedOffscreen.width = nWidth;
		CanvasDetailedOffscreen.height = nHeight;
	}
	MeasureFont();
	CreateViews(nWidth, nHeight);



}
function DrawHistory(View, LocalMouseX, LocalMouseY)
{
	ProfileEnter("DrawHistory");
	var Canvas = View.Canvas[View.BackBuffer];
	var context = Canvas.getContext('2d');
	context.clearRect(0, 0, View.w, View.h);
	if(!FrameData.Time)
		return;
	//var NumFrames = 0;//FrameCount
	var fHeight = View.h;
	var fWidth = nWidth / FrameCount;
	var fHeightScale = fHeight / ReferenceTime;
	var fX = 0;
	var FrameIndex = -1;
	var MouseDragging = 0;

	// MouseDragState != MouseDragOff;
	// RangeCpuHistory = RangeInit();
	// RangeGpuHistory = RangeInit()

	for(var i = 0; i < FrameCount; i++)
	{
		var idx = (FrameOffset + i) % FrameCount;
		if(idx < 0 || idx > FrameCount)
			debugger;
		var fMs = FrameData.Time[idx];

		var fH = fHeightScale * fMs;
		var bMouse = LocalMouseX > fX && LocalMouseX < fX + fWidth;
		if(bMouse && !MouseDragging)
		{
			context.fillStyle = FRAME_HISTORY_COLOR_GPU;
			// RangeCpuHistory.Begin = Frames[i].framestart;
			// RangeCpuHistory.End = Frames[i].frameend;
			// if(Frames[i].framestartgpu)
			// {
			// 	RangeGpuHistory.Begin = Frames[i].framestartgpu;
			// 	RangeGpuHistory.End = Frames[i].frameendgpu;
			// }
			// FrameIndex = i;
		}
		else
		{
			context.fillStyle = FRAME_HISTORY_COLOR_CPU;
		}
		context.fillRect(fX, fHeight - fH, fWidth-1, fH);
		fX += fWidth;
	}


	//range stuff
	// var fRangeHistoryBegin = FrameFirst;
	// var fRangeHistoryEnd = FrameLast;
	// var X = fRangeHistoryBegin;
	// var Y = 0;
	// var W = fRangeHistoryEnd - fRangeHistoryBegin;
	// context.globalAlpha = 0.35;
	// context.fillStyle = '#009900';
	// context.fillRect(X, Y, W, fHeight);
	// context.globalAlpha = 1;
	// context.strokeStyle = '#00ff00';
	// context.beginPath();
	// context.moveTo(X, Y);
	// context.lineTo(X, Y+fHeight);
	// context.moveTo(X+W, Y);
	// context.lineTo(X+W, Y+fHeight);
	// context.stroke();




	// DrawCaptureInfo(context);

	// if(FrameIndex>=0 && !MouseDragging)
	// {
	// 	var StringArray = [];
	// 	StringArray.push("Frame");
	// 	StringArray.push("" + FrameIndex);
	// 	StringArray.push("Time");
	// 	StringArray.push("" + (Frames[FrameIndex].frameend - Frames[FrameIndex].framestart).toFixed(3));

	// 	DrawToolTip(StringArray, CanvasHistory, HistoryViewMouseX, HistoryViewMouseY+20);

	// }
	ProfileLeave();

	View.OffscreenData[View.BackBuffer] = context.getImageData(0, 0, Canvas.width, Canvas.height);
}

function DrawViews()
{
	Plotf("DrawViews");
	ProfileEnter("UpdateViews");
	for(var i = 0; i < Views.length; ++i)
	{
		var View = Views[i];
		var LocalMouseX = MouseX - View.x;
		var LocalMouseY = MouseY - View.y;
		View.DisplayFunc(View, LocalMouseX, LocalMouseY);
	}
	ProfileLeave();
	var context = CanvasDetailedView.getContext('2d');
	ProfileEnter("BlitViews");
	for(var i = 0; i < Views.length; ++i)
	{
		var View = Views[i];
		context.putImageData(View.OffscreenData[View.BackBuffer], View.x, View.y);
	}
	ProfileLeave();

}

function DrawMenu()
{
	var context = CanvasDetailedView.getContext('2d');
	var nColorIndex = 0;
	var Y = 0;
	var Width = 800;
	var Selection = null;
	ProfileEnter("DrawMenu");

	function DrawMenuRecursive(Index, Indent)
	{
		ProfileEnter("DrawMenuRecursive");
		var X = 0;
		nColorIndex = 1-nColorIndex;
		var v = TimerArray[Index];
		var Closed = 0;
		if(Index > 0)
		{
			var Name = (v.e?'*':' ')+v.name;// + ' -> ' + v.id + ' -> ' + v.pid; idtype
			bMouseIn = MouseY >= Y && MouseY < Y + BoxHeight;

			var bgcolor = bMouseIn ? nBackColorOffset : nBackColors[nColorIndex];
			context.fillStyle = bgcolor;
			context.fillRect(0, Y, Width, BoxHeight);
			context.fillStyle = v.color;
			context.fillText(Name, Indent*FontWidth, Y+BoxHeight-FontAscent);
			if(bMouseIn)
			{
				Selection = v.id;

			}

			Y += BoxHeight;
		}

		if(!Closed)
		{
			var ChildIndex = v.firstchild;
			while(ChildIndex)
			{
				DrawMenuRecursive(ChildIndex, Indent + 1);
				ChildIndex = TimerArray[ChildIndex].sibling;
			}
		}
		ProfileLeave();
	}
	DrawMenuRecursive(0, -1);

	if(Selection && MouseReleased)
	{
		console.log('pressed on ' + Selection);
		WSSendMessage("c" + Selection);
	}
	ProfileLeave();
}
var ConnectionStr = ["\\", "|", "/", "-" ];
var ConnectionIdx = 0;
function DrawConnectionStatus()
{
	var Strings = new Array();
	Strings.push("Status");
	if(WSConnected && WS && WS.readyState == 1)
	{
		Strings.push("[X]");
	}
	else
	{
		ConnectionIdx = (ConnectionIdx + 1 ) % ConnectionStr.length;
		Strings.push("[" + ConnectionStr[ConnectionIdx]+"]");
	}
	Strings.push("Port");
	Strings.push("" + WSPort);
	Strings.push("Path");
	Strings.push("" + WSPath);
	Strings.push("Sends");
	Strings.push("" + WSSend);
	Strings.push("Receives");
	Strings.push("" + WSReceive);
	Strings.push("SendBytes");
	Strings.push("" + WSSendBytes);
	Strings.push("ReceiveBytes");
	Strings.push("" + WSReceiveBytes);
	Strings.push("Seconds");
	Strings.push("" + WSSeconds);


	DrawToolTip(Strings, CanvasDetailedView, 50000, 0);

}
function Draw()
{
	ProfileModeClear();
	ProfileEnter("Total");
	
	DrawMenu();

	DrawViews();

	DrawConnectionStatus();
	DrawPlotf(CanvasDetailedView);
	ProfileLeave();
	ProfileModeDraw(CanvasDetailedView);

	MouseReleased = false;
}
function RequestDraw()
{
	//requestAnimationFrame(Draw);
}

function AutoRedraw(Timestamp)
{
	Draw();
	PlotfClear();
	requestAnimationFrame(AutoRedraw);
}




function WSOpen()
{
	WSSend = 0;
	WSReceive = 0;
	WSSendBytes = 0;
	WSReceiveBytes = 0;

	TimerArray = [];
	TimerArray.push(Empty);

	ResetFrameData();

	console.log('socket is OPEN!! path ' + WSPath);
}

function SplitIdTop(v)
{
	return v >> 24; // todo: verify
}

function SplitIdBottom(v)
{
	return v & 0xffffff; // todo: verify
}

function GetTimer(id)
{
	for(var i = 0; i < TimerArray.length; ++i)
	{
		if(TimerArray[i].id == id)
		{
			return i;
		}
	}
	return null;
}
function EnableTimer(T)
{
	var idx = GetTimer(T.id);
	if(idx>=0)
	{
		TimerArray[idx].e = T.e;
	}
}
function AddTimer(T)
{
	var idx = TimerArray.length;
	var existing = GetTimer(T.id);
	if(existing)
	{
		idx = existing;
	}
	TimerArray[idx] = T;
	TimerArray[idx].idtype = SplitIdTop(T.id);
	TimerArray[idx].idelement = SplitIdBottom(T.id);
	var pidx = GetTimer(T.pid);
	if(pidx >= 0)
	{

		var Parent = TimerArray[pidx];
		var Sibling = Parent.firstchild;
		Parent.firstchild = idx;
		TimerArray[idx].sibling = Sibling;

	}
	else
	{
		debugger;//fail
	}
	console.log('add timer ' + idx + ' parent ' + pidx);
	RequestDraw();

}

function AllocClearedArray(Size)
{
	var A = new Array(Size);
	for(var i = 0; i < Size; ++i)
	{
		A[i] = 0;
	}
	return A;
}
function ResetFrameData()
{
	FrameData = {};
	FrameOffset = 0;
	FrameData.x = {};
	FrameData.Time = AllocClearedArray(FrameCount);
	FrameData.Ids = AllocClearedArray(FrameCount);
}
function GetFrameData(id)
{
	if(FrameData[id])
	{
		return FrameData[id];
	}
	else
	{
		var FD = {};
		FD.Count = AllocClearedArray(FrameCount);
		FD.Time = AllocClearedArray(FrameCount);
		FD.TimeExcl = AllocClearedArray(FrameCount);
		FrameData.x[id] = FD;
	}
}

function ProcessFrame(F)
{
	FrameData.Time[FrameOffset] = F.t;
	FrameData.Ids[FrameOffset] = F.f;
	for(var idx in F.x)
	{
		var FD = GetFrameData(idx);
		var Data = F[idx];
		FD.Time[FrameOffset] = Data[0];
		FD.TimeExcl[FrameOffset] = Data[1];
		FD.Count[FrameOffset] = Data[2];
	}
	FrameOffset = (FrameOffset + 1) % FrameCount;
}

function WSMessage()
{
	console.log(event.data);
	var Obj = JSON.parse(event.data);
	WSReceive++;
	WSReceiveBytes += event.data.length;
	var k = Obj.k;
	if(k == WSMsgTimerTree)
	{
		AddTimer(Obj.v);
	}
	else if(k == WSMsgEnabled)
	{
		console.log('got enable message ' + event);
		EnableTimer(Obj.v);
	}
	else if(k == WSMsgFrame)
	{
		console.log('frame message');
		ProcessFrame(Obj.v);
	}
}
function WSError()
{
	console.log('WSError');
}
function WSClose()
{
	console.log('WSClose');
}
function WSSendMessage(msgid)
{
	if(WSConnected)
	{
		var str = '' + msgid;
		WSSend++;
		WSSendBytes += str.length;
		WS.send(str);
	}
}


function Connect()
{
	if(WS && (WS.readyState == 1 || WS.readyState == 0))
	{
		WSConnected = WS.readyState == 1;
		WSFail = 0;
		WSSeconds = 0;
	}
	else
	{
		WSConnected = 0;
		WSSeconds = (new Date() - WSOpenTime);
		if(!WS || WSSeconds > 2000)
		{
			WSPort++;
			if(WSPort > 1338+2)
			{
				WSPort = 1338;
			}
			if(WS)
			{
				WS.close();
				WS = null;
			}
			WSOpenTime = new Date();
			WSPath = "ws://localhost:" + WSPort + "/ws";
			console.log('connecting to ' + WSPath);
			WS = new WebSocket(WSPath);
			WS.onopen = WSOpen;
			WS.onmessage = WSMessage;
			WS.onerror = WSError;
			WS.onclose = WSClose;
			WSFail = 0;
		}
		else
		{
			WSFail++;
		}
	}
}


function MouseMove(evt)
{
    evt.preventDefault();
 //    ZoomActive = 0;
 //    MouseDrag(MouseDragMove, evt);
 // 	MouseHistory = 0;
	// MouseDetailed = 0;
	// HistoryViewMouseX = HistoryViewMouseY = -1;
	var rect = evt.target.getBoundingClientRect();
	var x = evt.clientX - rect.left;
	var y = evt.clientY - rect.top;
	MouseX = x;
	MouseY = y;


	// if(evt.target == CanvasDetailedView)
	// {
	// 	if(!MouseDragSelectRange())
	// 	{
	// 		RangeCpu = RangeInit();
	// 	}
	// }
	// else if(evt.target = CanvasHistory)
	// {
	// 	var Rect = CanvasHistory.getBoundingClientRect();
	// 	HistoryViewMouseX = x;
	// 	HistoryViewMouseY = y;
	// }
	// Draw(1);
	//Draw();
}

function MouseButton(bPressed, evt)
{
    evt.preventDefault();
    MouseReleased = !bPressed;
	// MouseDrag(bPressed ? MouseDragDown : MouseDragUp, evt);
	// if(!bPressed)
	// {
	// 	if(SortColumnMouseOverNext)
	// 	{
	// 		if(SortColumnMouseOverNext == SortColumnMouseOver)
	// 		{
	// 			SortColumnOrderFlip =  1 - SortColumnOrderFlip;
	// 		}
	// 		else
	// 		{
	// 			SortColumnOrderFlip = 0;
	// 		}

	// 		SortColumnMouseOver = SortColumnMouseOverNext;
	// 		SortColumnMouseOverNext = null;
	// 		if(SortColumnMouseOver == StrAverage)
	// 		{
	// 			SortColumn = 1;
	// 		}
	// 		else if(SortColumnMouseOver == StrMax)
	// 		{
	// 			SortColumn = 2;
	// 		}
	// 		else if(SortColumnMouseOver == StrTotal)
	// 		{
	// 			SortColumn = 3;
	// 		}			
	// 		else if(SortColumnMouseOver == StrMin)
	// 		{
	// 			SortColumn = 4;
	// 		}
	// 		else if(SortColumnMouseOver == StrSpike)
	// 		{
	// 			SortColumn = 5;
	// 		}
	// 		else if(SortColumnMouseOver == StrCallAverage)
	// 		{
	// 			SortColumn = 6;
	// 		}
	// 		else if(SortColumnMouseOver == StrCount)
	// 		{
	// 			SortColumn = 7;
	// 		}
	// 		else if(SortColumnMouseOver == StrExclAverage)
	// 		{
	// 			SortColumn = 8;
	// 		}
	// 		else if(SortColumnMouseOver == StrExclMax)
	// 		{
	// 			SortColumn = 9;
	// 		}
	// 		else if(SortColumnMouseOver == StrGroup)
	// 		{
	// 			SortColumn = 0;
	// 		}
	// 		RequestRedraw();
	// 	}
	// }
}

function MouseOut(evt)
{
	// MouseDrag(MouseDragOff, evt);
	// KeyCtrlDown = 0;
	// KeyShiftDown = 0;
	// MouseDragButton = 0;
	// nHoverToken = -1;
	// RangeCpu = RangeInit();
}

function MouseWheel(e)
{
//     var e = window.event || e;
//     var delta = (e.wheelDelta || e.detail * (-120));
//     ZoomGraph((-4 * delta / 120.0) | 0);
//     Draw(1);
}

function KeyUp(evt)
{
	console.log('keyup ' + evt.keyCode);
	if(evt.keyCode == 220)
	{
		ProfileMode = !ProfileMode;
	}
	// if(evt.keyCode == 39)
	// {
	// 	MoveToNext(1);
	// }
	// if(evt.keyCode == 37)
	// {
	// 	MoveToNext(-1);
	// }
	// if(evt.keyCode == 17)
	// {
	// 	KeyCtrlDown = 0;
	// 	MouseDragKeyUp();
	// }
	// else if(evt.keyCode == 16)
	// {
	// 	KeyShiftDown = 0;
	// 	MouseDragKeyUp();
	// }
	// if(evt.keyCode == 32)
	// {
	// 	if(RangeSelect.Begin < RangeSelect.End)
	// 	{
	// 		ZoomTo(RangeSelect.Begin, RangeSelect.End);
	// 		RangeSelect = RangeInit();
	// 		MouseHandleDragEnd();
	// 	}
	// }
	// if(evt.keyCode == 9)
	// {
	// 	evt.preventDefault();
	// 	if(Mode == ModeDetailed)
	// 	{
	// 		var Token = nHoverToken;
	// 		if(Token == -1 && RangeValid(RangeSelect) && RangeSelect.Index >= 0)
	// 		{
	// 			Token = RangeSelect.Index;
	// 		}
	// 		if(Token != -1 && Token < TimerInfo.length)
	// 		{
	// 			var start = TimerInfo[Token].worststart;
	// 			var end = TimerInfo[Token].worstend;
	// 			RangeSelect.Begin = start;
	// 			RangeSelect.End = end;
	// 			RangeSelect.Thread = TimerInfo[Token].worstthread;
	// 			RangeSelect.Index = Token;
	// 			ShowFlashMessage('Worst: ' + (end-start).toFixed(2) + 'ms', 100);
	// 			MoveTo(RangeSelect.Begin, RangeSelect.End, ThreadY[RangeSelect.Thread] + nOffsetY, ThreadY[RangeSelect.Thread+1] + nOffsetY);
	// 			MouseHandleDragEnd();
	// 		}
	// 	}
	// 	else if(Mode == ModeTimers)
	// 	{
	// 		ToggleFilterInput(0);
	// 		evt.preventDefault();
	// 	}

	// }
	// if(evt.keyCode == 27)
	// {
	// 	RangeSelect = RangeInit();
	// 	SortColumn = 0;
	// 	SortColumnMouseOver = "";
	// 	if(Mode == ModeTimers)
	// 	{
	// 		ToggleFilterInput(1);
	// 		evt.preventDefault();
	// 	}
	// }

	// if(evt.keyCode == 18 || evt.keyCode == 90) // z/tab to toggle tooltip
	// {
	// 	ToolTip = (ToolTip+1)%3; //0: off, 1: default, 2: flipped
	// 	var ToolTipStr = 'Off';
	// 	var bShowTimers = Mode == ModeTimers;
	// 	if(ToolTip == 2)
	// 	{
	// 		bShowTimers = !bShowTimers;
	// 	}
	// 	if(ToolTip)
	// 	{
	// 		if(bShowTimers)
	// 			ToolTipStr = "Timers";
	// 		else
	// 			ToolTipStr = "Detailed";
	// 	}
	// 	ShowFlashMessage('ToolTip: ' + ToolTipStr, 100);
	// }


	// Invalidate = 0;
}

function KeyDown(evt)
{
	// if(evt.keyCode == 17)
	// {
	// 	KeyCtrlDown = 1;
	// }
	// else if(evt.keyCode == 16)
	// {
	// 	KeyShiftDown = 1;
	// }
	// else if(evt.keyCode == 9)
	// {
	// 	evt.preventDefault();
	// }
	// Invalidate = 0;
}


function SetupEvents()
{
	var mousewheelevt = (/Firefox/i.test(navigator.userAgent)) ? "DOMMouseScroll" : "mousewheel" //FF doesn't recognize mousewheel as of 
	CanvasDetailedView.addEventListener('mousemove', MouseMove, false);
	CanvasDetailedView.addEventListener('mousedown', function(evt) { MouseButton(true, evt); });
	CanvasDetailedView.addEventListener('mouseup', function(evt) { MouseButton(false, evt); } );
	CanvasDetailedView.addEventListener('mouseout', MouseOut);
	CanvasDetailedView.addEventListener("contextmenu", function (e) { e.preventDefault(); }, false);
	CanvasDetailedView.addEventListener(mousewheelevt, MouseWheel, false);
	// FilterInputTimer.addEventListener('keyup', FilterKeyUp);
	// FilterInputGroup.addEventListener('keyup', FilterKeyUp);
	window.addEventListener('keydown', KeyDown);
	window.addEventListener('keyup', KeyUp);
	window.addEventListener('resize', ResizeCanvas, false);
}

function DrawToolTip(StringArray, Canvas, x, y)
{
	var context = Canvas.getContext('2d');
	context.font = Font;
	var WidthArray = Array(StringArray.length);
	var nMaxWidth = 0;
	var nHeight = 0;
	for(i = 0; i < StringArray.length; i += 2)
	{
		var nWidth0 = context.measureText(StringArray[i]).width;
		var nWidth1 = context.measureText(StringArray[i+1]).width;
		var nSum = nWidth0 + nWidth1;
		WidthArray[i] = nWidth0;
		WidthArray[i+1] = nWidth1;
		if(nSum > nMaxWidth)
		{
			nMaxWidth = nSum;
		}
		nHeight += BoxHeight;
	}
	nMaxWidth += 15;
	//bounds check.
	var CanvasRect = Canvas.getBoundingClientRect();
	if(y + nHeight > CanvasRect.height)
	{
		y = CanvasRect.height - nHeight;
		x += 20;
	}
	if(x + nMaxWidth > CanvasRect.width)
	{
		x = CanvasRect.width - nMaxWidth;
	}

	context.fillStyle = 'black';
	context.fillRect(x-1, y, nMaxWidth+2, nHeight);
	context.fillStyle = 'white';

	var XPos = x;
	var XPosRight = x + nMaxWidth;
	var YPos = y + BoxHeight-2;
	for(i = 0; i < StringArray.length; i += 2)
	{
		context.fillText(StringArray[i], XPos, YPos);
		context.fillText(StringArray[i+1], XPosRight - WidthArray[i+1], YPos);
		YPos += BoxHeight;
	}
}

function DrawPlotf(Canvas)
{
	return;
	var context = Canvas.getContext('2d');
	context.font = Font;
	var WidthArray = Array(PlotfArray.length);
	var nMaxWidth = 0;
	var nHeight = 0;

	context.font = Font;
	for(i = 0; i < PlotfArray.length; i++)
	{
		var nWidth = context.measureText(PlotfArray[i]).width;
		WidthArray[i] = nWidth;
		if(nWidth > nMaxWidth)
		{
			nMaxWidth = nWidth;
		}
		nHeight += BoxHeight;
	}
	nMaxWidth += 15;
	var x = 0;
	var y = 0;

	context.fillStyle = 'black';
	context.fillRect(x-1, y, nMaxWidth+2, nHeight);
	context.fillStyle = 'white';

	var XPos = x;
	var XPosRight = x + nMaxWidth;
	var YPos = y + BoxHeight-2;
	for(i = 0; i < PlotfArray.length; i++)
	{
		context.fillText(PlotfArray[i], XPos, YPos);
		YPos += BoxHeight;
	}
}

ResizeCanvas();
SetupEvents();

setInterval(Connect, 10);



//Draw();
AutoRedraw();


</script>
</body>
</html>      


