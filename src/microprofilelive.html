<!DOCTYPE HTML>
<html>
<head>
<title>MicroProfile Capture</title>
<style>
/* about css: http://bit.ly/1eMQ42U */
body {margin: 0px;padding: 0px; font: 12px Courier New;background-color:#474747; color:white;overflow:hidden;}
ul {list-style-type: none;margin: 0;padding: 0;}
li{display: inline; float:left;border:5px; position:relative;text-align:center;}
a {
    float:left;
    text-decoration:none;
    display: inline;
    text-align: center;
	padding:5px;
	padding-bottom:0px;
	padding-top:0px;
    color: #FFFFFF;
    background-color: #474747;
}
a:hover, a:active{
	background-color: #000000;
}

ul ul {
    position:absolute;
    left:0;
    top:100%;
    margin-left:-999em;
}
li:hover ul {
    margin-left:0;
    margin-right:0;
}
ul li ul{ display:block;float:none;width:100%;}
ul li ul li{ display:block;float:none;width:100%;}
li li a{ display:block;float:none;width:100%;text-align:left;}
#nav li:hover div {margin-left:0;}
.help {position:absolute;z-index:5;text-align:left;padding:2px;margin-left:-999em;background-color: #313131;width:300px;}
.helpstart {position:absolute;z-index:5;text-align:left;padding:2px;background-color: #313131;width:300px;display:none}
.root {z-index:1;position:absolute;top:0px;left:0px;}
.filterinput0{position:fixed; background-color: #313131;display:none;}
.filterinput{width:100px;}
</style>
</head>
<body style="">
<div class="filterinput0" id="FilterInputDiv">Filter<br><input type="text" id="FilterInput" class="filterinput"></div>
<canvas id="DetailedView" height="100%" style="background-color:#474747;margin:0px;padding:0px;"></canvas>
<script>
"use strict"


//todo
// on demand redraw
// selection
// base graph
//connection status window
// log window 
// menu item
//scrolling in menu
//sub menus
// TimerMap view
// graph view


//settings to implement
// aggregate
// reference time
// preset menu
//



var FRAME_HISTORY_COLOR_CPU = '#ff7f27';
var FRAME_HISTORY_COLOR_GPU = '#ffffff';


var HistoryHeight = 100;
var CanvasDetailedView = document.getElementById('DetailedView');
var CanvasDetailedOffscreen = document.createElement('canvas');
var FilterInput = document.getElementById('FilterInput');
var FilterInputDiv = document.getElementById('FilterInputDiv');

var CanvasArray0 = [];
var CanvasArray1 = [];
var Views = [];

var nWidth = CanvasDetailedView.width;
var nHeight = CanvasDetailedView.height;
var nBackColors = ['#474747', '#313131' ];
var nBackColorOffset = '#606060';
var FontHeight = 10;
var FontWidth = 1;
var FontAscent = 3; //Set manually
var Font = 'Bold ' + FontHeight + 'px Courier New';
var FontFlash = 'Bold ' + 35 + 'px Courier New';
var BoxHeight = FontHeight + 2;
var MouseX = 0;
var MouseY = 0;
var MouseReleased = false;
var DPR = 0;

var ReferenceTime = 33.0;
var ReferencePresets = [5.0, 10.0, 15.0, 20,33.33,66.66,100.0,250.0,500,1000.0];


var AggregateFrames = 60;
var AggregatePresets = [-1, 10,20,30,60,90,120];

var ProfileMode = 0;
var ProfileRedraw0 = 0;
var ProfileRedraw1 = 0;
var ProfileRedraw2 = 0;
var ProfileFps = 0;
var ProfileFpsAggr = 0;
var ProfileFpsCount = 0;
var ProfileLastTimeStamp = new Date();
var PlotfArray = new Array();

var ConnectionStr = ["\\", "|", "/", "-" ];
var ConnectionIdx = 0;


var FrameData = {};
var FrameCount = 256;
var FramePending = 0;

var WSConnected = 0;
var WSSeconds = 0;
var WSFail = 0;
var WS;
var WSPort = 1338;
var WSPath;

var MSG_TIMER_TREE = 1; //MSG_TIMER_TREE
var MSG_ENABLED = 2; // MSG_ENABLED
var MSG_FRAME = 3; // MSG_FRAME

var TYPE_NONE = 0;
var TYPE_TIMER = 1;
var TYPE_GROUP = 2;
var TYPE_CATEGORY = 3;


var WSSend = 0;
var WSReceive = 0;
var WSSendBytes = 0;
var WSReceiveBytes = 0;
var WSOpenTime = 0;


var TimerArray = [];
var Empty = {"id":0, "w":0, "depth":0};
var WidthArray = [];
var WidthTree = 0;

TimerArray.push(Empty); // 0 is root of tree



function Plotf(str)
{
	PlotfArray.push(str)
}
function PlotfClear()
{
	PlotfArray = new Array();
}

function ProfileModeClear()
{
	if(ProfileMode)
	{
		ProfileData = new Object();
		ProfileStackTime = new Array();
		ProfileStackName = new Array();
	}
}
function ProfileEnter(Name)
{
	if(ProfileMode)
	{
		ProfileStackTime.push(new Date());
		ProfileStackName.push(Name);
	}
}
function ProfileLeave()
{
	if(ProfileMode)
	{
		var Time = new Date();
		var Delta = Time - ProfileStackTime.pop();
		var Name = ProfileStackName.pop();
		var Obj = ProfileData[Name];
		if(!Obj)
		{
			Obj = new Object();
			Obj.Count = 0;
			Obj.Name = Name;
			Obj.Time = 0;
			ProfileData[Name] = Obj;
		}
		Obj.Time += Delta;
		Obj.Count += 1;
	}
}

function ProfilePlot(s)
{
	if(ProfileMode)
	{
		var A = ProfileData.Plot;
		if(!A)
		{
			ProfileData.Plot = Array();
			A = ProfileData.Plot;
		}
		if(A.length<10)
		{
			A.push(s);
		}
	}
}
function ProfileModeDump()
{
	for(var idx in ProfileData)
	{
		var Timer = ProfileData[idx];
		console.log(Timer.Name + " " + Timer.Time + "ms " + Timer.Count);
	}

}
function ProfileModeDraw(Canvas)
{
	if(ProfileMode)
	{
		var StringArray = [];
		for(var idx in ProfileData)
		{
			if(idx == "Plot")
				continue;
			var Timer = ProfileData[idx];
			StringArray.push(Timer.Name);
			StringArray.push(Timer.Time + "ms");
			StringArray.push("#");
			StringArray.push("" + Timer.Count);
		}
		// StringArray.push("debug");
		// StringArray.push(Debug);
		var Time = new Date();
		var Delta = Time - ProfileLastTimeStamp;
		ProfileLastTimeStamp = Time;
		StringArray.push("Frame Delta");
		StringArray.push(Delta + "ms");
		if(ProfileMode == 2)
		{
			ProfileFpsAggr += Delta;
			ProfileFpsCount ++ ;
			var AggrFrames = 10;
			if(ProfileFpsCount == AggrFrames)
			{
				ProfileFps = 1000 / (ProfileFpsAggr / AggrFrames);
				ProfileFpsAggr = 0;
				ProfileFpsCount = 0;
			}
			StringArray.push("FPS");
			StringArray.push("" + ProfileFps.toFixed(2));
		}
		for(var i = 0; i < ProfileData.Plot; ++i)
		{
			StringArray.push("");
			StringArray.push(ProfileData.Plot[i]);
		}
		ProfileData.Plot = Array();
		DrawToolTip(StringArray, Canvas, 0, 200);
	}
}



function MeasureFont()
{
	var context = CanvasDetailedView.getContext('2d');
	//context.font = Font;
	FontWidth = context.measureText('W').width;

}
function ResizeCanvasDPR(w, h, c)
{
	DPR = window.devicePixelRatio;
	if(DPR)
	{
		c.style.width = w + 'px'; 
		c.style.height = h + 'px';
		c.width = w * DPR;
		c.height = h * DPR;
		c.getContext('2d').scale(DPR,DPR);
	}
	else
	{
		c.width = w;
		c.height = h;
	}

}

function ResizeCanvasDPR2(w, h, c)
{
	DPR = window.devicePixelRatio;
	if(DPR)
	{
		c.style.width = w + 'px'; 
		c.style.height = h + 'px';
		c.width = w * DPR;
		c.height = h * DPR;
		c.getContext('2d').scale(DPR,DPR);
	}
	else
	{
		c.width = w;
		c.height = h;
	}

}
function CreateView(x, y, w, h, name, DisplayFunc)
{
	var idx = Views.length;
	var c0 = CanvasArray0[idx];
	var c1 = CanvasArray1[idx];
	if(!c0)
	{
		c0 = document.createElement('canvas');
		CanvasArray0[idx] = c0;
	}
	if(!c1)
	{
		c1 = document.createElement('canvas');
		CanvasArray1[idx] = c1;
	}
	var View = {};
	View.x = x;
	View.y = y;
	View.w = w;
	View.h = h;
	View.Canvas = [c0, c1];
	View.OffscreenData = [null, null];
	ResizeCanvasDPR(w, h, c0);
	ResizeCanvasDPR(w, h, c1);

	c0.getContext('2d').clearRect(0, 0, w, h);
	c1.getContext('2d').clearRect(0, 0, w, h);
	View.OffscreenData[0] = c0.getContext('2d').getImageData(0, 0, c0.width, c0.height);
	View.OffscreenData[1] = c1.getContext('2d').getImageData(0, 0, c1.width, c1.height);
	View.BackBuffer = 0;
	View.DisplayFunc = DisplayFunc;
	return View;
}

function CreateViews(Width, Height)
{
	Views = [];
	var History = CreateView(0, 0, Width, HistoryHeight, "History", DrawHistory);
	Views.push(History);
	var MainView = CreateView(0, HistoryHeight, Width, Height-HistoryHeight, "Main", DrawBars);
	Views.push(MainView);
}

function ResizeCanvas() 
{
	nWidth = window.innerWidth;
	nHeight = window.innerHeight;
	DPR = window.devicePixelRatio;
	ResizeCanvasDPR(nWidth, nHeight, CanvasDetailedView);
	ResizeCanvasDPR(nWidth, nHeight, CanvasDetailedOffscreen);

	if(DPR)
	{
		CanvasDetailedView.style.width = nWidth + 'px'; 
		CanvasDetailedView.style.height = nHeight + 'px';
		CanvasDetailedView.width = nWidth * DPR;
		CanvasDetailedView.height = nHeight * DPR;
		CanvasDetailedView.getContext('2d').scale(DPR,DPR);

		CanvasDetailedOffscreen.style.width = nWidth + 'px';
		CanvasDetailedOffscreen.style.height = nHeight + 'px';
		CanvasDetailedOffscreen.width = nWidth * DPR;
		CanvasDetailedOffscreen.height = nHeight * DPR;
		CanvasDetailedOffscreen.getContext('2d').scale(DPR,DPR);

	}
	else
	{
		DPR = 1;
		CanvasDetailedView.width = nWidth;
		CanvasDetailedView.height = nHeight;
		CanvasDetailedOffscreen.width = nWidth;
		CanvasDetailedOffscreen.height = nHeight;
	}
	MeasureFont();
	CreateViews(nWidth, nHeight);
}

// function DrawGraph(View, LocalMouseX, LocalMouseY)
// {
// 	var Bars = FrameData.TimerMap;
// 	if(!Bars)
// 		return;

// 	ProfileEnter("DrawGraph");
// 	var CanvasPrev = View.Canvas[View.BackBuffer];
// 	var OffscreenPrev = View.OffscreenData[View.BackBuffer];
// 	View.BackBuffer = 1 - View.BackBuffer;
// 	var Canvas = View.Canvas[View.BackBuffer];
// 	var context = Canvas.getContext('2d');
	
// 	context.clearRect(0, 0, View.w, View.h);
// 	// context.drawImage(CanvasPrev, -1, 0, View.w, View.h);
// 	// context.putImageData(OffscreenPrev, View.OffscreenData[View.BackBuffer], View.x*2, View.y*2);
// 	// context.fillStyle = '#005500';
// 	// context.fillRect(0, 0, 1000, 1000);

// 	var h = View.h;
// 	var h1 = h-1;
// 	var w = View.w;
// 	var fHeightScale = h / ReferenceTime;
// 	var MouseDragging = 0;

// 	// MouseDragState != MouseDragOff;
// 	// RangeCpuHistory = RangeInit();
// 	// RangeGpuHistory = RangeInit()
	
// 	var FrameBegin = FramePendingBegin;
// 	var FrameEnd = FramePendingEnd;
// 	var NumFrames = FrameEnd - FrameBegin;

// 	if(FrameEnd < FrameBegin)
// 	{
// 		NumFrames = FrameEnd + FrameCount - FrameBegin;
// 	}
// 	if(NumFrames < 0)
// 		debugger;

// 	if(FrameEnd - FrameBegin > FrameCount -1 )
// 	{
// 		if(FrameEnd < FrameCount)
// 			debugger;
// 		FrameBegin = FrameEnd - FrameCount + 1;
// 	}
// 	//var NumFrames = FrameEnd - FrameBegin;
// 	var Keys = [];
// 	for(var key in Bars)
// 	{
// 		Keys.push(key);
// 	}
// 	console.log('numframes ' + NumFrames);
// 	if(0 != NumFrames)
// 	{
// 		context.drawImage(CanvasPrev, -NumFrames, 0, View.w, View.h);
		
// 		var dY = i * 2;
// 		var FramesLeft = NumFrames;

// 		for(var i = FrameBegin; i != FrameEnd; i = (i+1) % FrameCount)
// 		{
// 			ProfileEnter("loop0");
// 			//sort indices based on timer value.
// 			Keys.sort( function(a, b){ 
// 				var BlockA = Bars[a];
// 				var BlockB = Bars[b];
// 				var TimeArrayA = BlockA.Time;
// 				var TimeArrayB = BlockB.Time;
// 				return TimeArrayA[i] - TimeArrayB[i];
// 			} );
// 			var Y = h1;
// 			var X = w-FramesLeft;
// 			FramesLeft -= 1;
// 			var TimeLast = 0;
// 			for(var x = 0; x < Keys.length; ++x)
// 			{
// 				ProfileEnter("loop1");

// 				var k = Keys[x];
// 				var idx = GetTimer(k);
// 				if(!idx && 0 != idx)
// 				{
// 					debugger;
// 				}
// 				var color = TimerArray[idx].color;
// 				var TimerState = Bars[k];
// 				var TimeArray = Block.Time;
// 				var t = TimeArray[(FrameBegin + i) % FrameCount];
// 				if(t > ReferenceTime)
// 					ReferenceTime = t;
// 				if(t < TimeLast)
// 				{
// 					ProfileLeave();
// 					break;
// 				}
// 				dY = (t-TimeLast) * fHeightScale;
// 				context.strokeStyle = color;
// 				context.beginPath();
// 				// context.moveTo(0,0);
// 				// context.lineTo(w,h);
// 				// context.lineTo(0,h);
// 				// context.lineTo(w, 0);			
// 				context.moveTo(X, Y);
// 				Y -= dY;
// 				context.lineTo(X, Y);
// 				context.stroke();

// 				TimeLast = t;
// 			}
// 			ProfileLeave();
// 		}
// 	}
// 	else
// 	{
// 			context.drawImage(CanvasPrev, 0, 0, View.w, View.h);

// 	}
// 	ProfileLeave();
// }

function FormatTime(Time)
{
	return Time.toFixed(2) + 'ms';
}
function DrawBars(View, LocalMouseX, LocalMouseY)
{
	var TimerMap = FrameData.TimerMap;
	if(!TimerMap)
		return;

	ProfileEnter("DrawBar");
	var Canvas = View.Canvas[View.BackBuffer];
	var context = Canvas.getContext('2d');
	context.clearRect(0, 0, View.w, View.h);
	var nNumBars = 0;
	for(var key in TimerMap)
	{
		var idx = GetTimer(key);
		var T = TimerArray[idx];
		if(T.e)
		{
			nNumBars++;
		}
	}
	if(!nNumBars)
		return;

	var h = View.h;
	var w = View.w;
	var DrawX = 25;
	var DrawY = 25;
	var DrawWidth = w -  2 * DrawX;
	var DrawHeight = h - 2 * DrawY;
	var SpaceWidth = 10;
	var BarWidth = (DrawWidth-SpaceWidth*(nNumBars-1))/ nNumBars;
	if(BarWidth > 50)
		BarWidth = 50;
	var BarHeight = DrawHeight - 10;

	var fHeightScale = h / ReferenceTime;
	var MouseDragging = 0;
	var fWidth = w / FrameCount;
	var Keys = [];
	var X = DrawX;
	context.textAlign = 'right';
	var offset = 0;
	for(var key in TimerMap)
	{
		var idx = GetTimer(key);
		var T = TimerArray[idx];
		if(T.e)
		{
			var TimerState = TimerMap[key];
			var Time = TimerState.FrameTime;
			var color = T.color;
			var fPrc = TimerState.FrameTime / ReferenceTime;
			if(fPrc > 1.0)
				fPrc = 1.0
			var BarH = fPrc * BarHeight;

			var X0 = X;
			var Y0 =  DrawX + DrawHeight - BarH;
			context.fillStyle = color;
			context.fillRect(X0, Y0, BarWidth, BarH);
			context.fillStyle = '#ffffff';
			var TimeText = FormatTime(TimerState.FrameTime);
			context.fillText(TimeText, X+BarWidth, DrawX+DrawHeight + FontHeight);
			context.fillStyle = color;
			context.fillText(T.name, X+BarWidth, DrawY - yoffset);
			X += BarWidth + SpaceWidth;
			context.strokeStyle = color;
		}
	}
	ProfileLeave();
}



function DrawGraph(View, LocalMouseX, LocalMouseY)
{
	//return;
	var TimerMap = FrameData.TimerMap;
	if(!TimerMap)
		return;

	ProfileEnter("DrawGraph");
	var CanvasPrev = View.Canvas[View.BackBuffer];
	var OffscreenPrev = View.OffscreenData[View.BackBuffer];
	View.BackBuffer = 1 - View.BackBuffer;
	var Canvas = View.Canvas[View.BackBuffer];
	var context = Canvas.getContext('2d');
	context.clearRect(0, 0, View.w, View.h);

	var h = View.h;
	//var h1 = h-1;
	var w = View.w;
	var fHeightScale = h / ReferenceTime;
	var MouseDragging = 0;
	var fWidth = w / FrameCount;

	var Keys = [];
	for(var key in TimerMap)
	{
		var idx = GetTimer(key);
		var TimerState = TimerMap[key];
		var Time = TimerState.Time;
		var color = TimerArray[idx].color;
		var X = w - Time.length*fWidth;
		var Y = h;
		context.strokeStyle = color;
		context.fillStyle = color;

		context.beginPath();
		context.moveTo(X,Y);
		for(var i = 0; i < Time.length; ++i)
		{
			Y = h - Time[i] * fHeightScale;
			context.lineTo(X, Y);
			X += fWidth;
		}
		context.lineTo(X,h);
		context.stroke();
	}

	ProfileLeave();
}


function DrawHistory(View, LocalMouseX, LocalMouseY)
{
	ProfileEnter("DrawHistory");
	var Canvas = View.Canvas[View.BackBuffer];
	var context = Canvas.getContext('2d');
	context.clearRect(0, 0, View.w, View.h);
	if(!FrameData.Time)
		return;
	var fHeight = View.h;
	var fWidth = nWidth / FrameCount;
	var fHeightScale = fHeight / ReferenceTime;
	var fX = 0;
	var FrameIndex = -1;
	var MouseDragging = 0;
	for(var i = 0; i < FrameCount; i++)
	{
		var fMs = FrameData.Time[i];

		var fH = fHeightScale * fMs;
		var bMouse = LocalMouseX > fX && LocalMouseX < fX + fWidth;
		if(bMouse && !MouseDragging)
		{
			context.fillStyle = FRAME_HISTORY_COLOR_GPU;
		}
		else
		{
			context.fillStyle = FRAME_HISTORY_COLOR_CPU;
		}
		context.fillRect(fX, fHeight - fH, fWidth-1, fH);
		fX += fWidth;
	}
	ProfileLeave();

}

function DrawViews()
{
	Plotf("DrawViews");
	ProfileEnter("UpdateViews");
	for(var i = 0; i < Views.length; ++i)
	{
		var View = Views[i];
		var LocalMouseX = MouseX - View.x;
		var LocalMouseY = MouseY - View.y;
		View.DisplayFunc(View, LocalMouseX, LocalMouseY);
		var Canvas = View.Canvas[View.BackBuffer];
		var Context = Canvas.getContext('2d');
		ProfileLeave();
	}
	ProfileLeave();
	var context = CanvasDetailedView.getContext('2d');
	context.clearRect(0, 0, nWidth, nHeight);
	ProfileEnter("BlitViews");
	var DPR = window.devicePixelRatio;
	for(var i = 0; i < Views.length; ++i)
	{
		var View = Views[i];
		context.drawImage(View.Canvas[View.BackBuffer], View.x, View.y, View.w, View.h);
	}
	ProfileLeave();

}
var SubMenuGroup = 0;
var SubMenuTimers = 1;
var SubMenuSettings = 2;
var SubMenuActive = -1;
var MenuItems = [];

function MakeMenuItem(name, f)
{
	var Item = {};
	Item.name = name
	Item.f = f;
	Item.w = name.length;
	return Item;
}
function ToggleSubMenu(m)
{
	if(m != SubMenuActive)
	{
		SubMenuActive = m;
	}
	else
	{
		SubMenuActive = -1;
	}
	if(SubMenuActive == 1)
	{

		var s = TimerMenuSize();
		FilterInputDiv.style['display'] = 'inline';
		var y = s.y - 40;
		FilterInputDiv.style['left'] = s.x + 'px';
		FilterInputDiv.style['top'] = y + 'px';
		FilterInputDiv.style['right'] = (s.x+s.w) + 'px';
		FilterInput.style['width'] = s.w + 'px';
		FilterInput.focus();


	}
	else
	{
		FilterInputDiv.style['display'] = 'none';
	}
	console.log("submenuactive " + SubMenuActive);
}
function InitMenu()
{
	MenuItems = [];
	MenuItems.push(MakeMenuItem("Control", function(){ToggleSubMenu(SubMenuGroup); } ));
	MenuItems.push(MakeMenuItem("Timers", function(){ToggleSubMenu(SubMenuTimers); } ));
	MenuItems.push(MakeMenuItem("Settings", function(){ ToggleSubMenu(SubMenuSettings); } ));
	MenuItems.push(MakeMenuItem("Capture", function(){ ToggleSubMenu(SubMenuSettings); } ));
	MenuItems.push(MakeMenuItem("Presets", function(){ ToggleSubMenu(SubMenuSettings); } ));
}
function DrawTopMenu()
{
	var context = CanvasDetailedView.getContext('2d');
	var X = 2;
	var Y = 0;
	var MouseInY = MouseY < BoxHeight;
	for(var i = 0; i < MenuItems.length; ++i)
	{
		var Item = MenuItems[i];
		var w = context.measureText(Item.name).width + 4;
		var MouseIn = MouseInY && MouseX >= X && MouseX < X + w;
		var color = MouseIn ? nBackColors[1] : "black";
		if(i == SubMenuActive)
		{
			context.fillStyle = 'white';
			context.fillRect(X-2, Y, w+4, BoxHeight);
		}
		context.fillStyle = color;
		context.fillRect(X, Y, w, BoxHeight);
		context.fillStyle = "white";
		context.fillText(Item.name, X+2, Y+BoxHeight-FontAscent);
		if(MouseIn && MouseReleased)
		{
			Item.f();
		}
		X += w + 6;
	}
}

function AggregateMenuSize()
{
	var Obj = {};
	Obj.w = 250 + 5 + FontWidth;
	Obj.x = nWidth / 2 - Obj.w / 2;
	Obj.y = HistoryHeight + 50;
	return Obj;
}

function TimerMenuSize()
{
	var Obj = {};
	Obj.w = WidthArray[TYPE_TIMER] + WidthArray[TYPE_GROUP] + 5 + FontWidth;
	Obj.x = nWidth / 2 - Obj.w / 2;
	Obj.y = HistoryHeight + 50;
	return Obj;
}
function GroupMenuSize()
{
	var Obj = {};
	Obj.w = WidthTree;
	Obj.x = nWidth / 2 - Obj.w / 2;
	Obj.y = HistoryHeight + 50;
	return Obj;
}

function CreateFilter(Filter)
{
	if(!Filter || Filter.length == 0)
	{
		return null;
	}
	Filter = Filter.split(' ');
	for(var i = 0; i < Filter.length; ++i)
	{
		Filter[i] = new RegExp(Filter[i], "i");
	}
	return Filter;
}

function FilterMatch(FilterArray, value)
{
	if(!FilterArray)
		return true;
	for(var i = 0; i < FilterArray.length; ++i)
	{
		var res = value.search(FilterArray[i]);
		if(res<0)
			return false;
	}
	return true;
}
function DrawSettingsMenu()
{
	var context = CanvasDetailedView.getContext('2d');
	var nColorIndex = 0;
	var SizeInfo = AggregateMenuSize();
	var Y = SizeInfo.y;
	var Width = SizeInfo.w;
	var Selection = null;
	var X = SizeInfo.x;
	for(var i = 0; i < AggregatePresets.length; ++i)
	{
		var Preset = AggregatePresets[i];
		var Selected = AggregateFrames == Preset;
		var Name = Preset < 0 ? "inifnite" : (Preset + '');
		var bMouseIn = MouseY >= Y && MouseY < Y + BoxHeight;
		var bgcolor = bMouseIn ? nBackColorOffset : nBackColors[nColorIndex];
		var TextY = Y+BoxHeight-FontAscent;
		if(Selected)
		{
			context.fillStyle = 'white';
			context.fillRect(X-2, Y, Width+4, BoxHeight);
		}
		context.fillStyle = bgcolor;
		context.fillRect(X, Y, Width, BoxHeight);
		context.fillStyle = 'white';
		context.fillText("Aggregate", X + 2, TextY);
		context.textAlign = 'right';
		context.fillText(Name, X + Width - 2, TextY);
		context.textAlign = 'left';
		if(bMouseIn && MouseReleased)
		{
			AggregateFrames = Preset;
		}
		Y += BoxHeight;
		nColorIndex = 1-nColorIndex;
	}

	for(var i = 0; i < ReferencePresets.length; ++i)
	{
		var Preset = ReferencePresets[i];
		var Selected = ReferenceTime == Preset;
		var Name = Preset + '';
		var bMouseIn = MouseY >= Y && MouseY < Y + BoxHeight;
		var bgcolor = bMouseIn ? nBackColorOffset : nBackColors[nColorIndex];
		var TextY = Y+BoxHeight-FontAscent;
		if(Selected)
		{
			context.fillStyle = 'white';
			context.fillRect(X-2, Y, Width+4, BoxHeight);
		}
		context.fillStyle = bgcolor;
		context.fillRect(X, Y, Width, BoxHeight);
		context.fillStyle = 'white';
		context.fillText("Reference", X + 2, TextY);
		context.textAlign = 'right';
		context.fillText(Name, X + Width - 2, TextY);
		context.textAlign = 'left';
		if(bMouseIn && MouseReleased)
		{
			ReferenceTime = Preset;
		}
		Y += BoxHeight;
		nColorIndex = 1-nColorIndex;
	}


}


function DrawTimerMenu()
{
	var FilterArray = CreateFilter(FilterInput.value);
	var context = CanvasDetailedView.getContext('2d');
	var nColorIndex = 0;
	var SizeInfo = TimerMenuSize();
	var Y = SizeInfo.y;
	var Width = SizeInfo.w;
	var Selection = null;
	var X = SizeInfo.x;
	for(var i = 0; i < TimerArray.length; ++i)
	{
		var v = TimerArray[i];
		if(v.idtype == TYPE_TIMER)
		{
			var Name = v.name;
			if(FilterMatch(FilterArray, Name))
			{
				var ParentName = TimerArray[v.pidx].name;
				var ParentColor = TimerArray[v.pidx].e ? 'white' : 'grey';
				var bMouseIn = MouseY >= Y && MouseY < Y + BoxHeight;
				var bgcolor = bMouseIn ? nBackColorOffset : nBackColors[nColorIndex];
				var TextY = Y+BoxHeight-FontAscent;
				if(v.e)
				{
					context.fillStyle = 'white';
					context.fillRect(X-2, Y, Width+4, BoxHeight);

				}
				context.fillStyle = bgcolor;
				context.fillRect(X, Y, Width, BoxHeight);
				context.fillStyle = ParentColor;
				context.fillText(ParentName, X + 2, TextY);
				context.fillStyle = v.color;
				context.textAlign = 'right';
				context.fillText(Name, X + Width - 2, TextY);
				context.textAlign = 'left';
				if(bMouseIn)
				{
					Selection = v.id;
				}
				Y += BoxHeight;
				nColorIndex = 1-nColorIndex;
			}
		}
	}
	if(Selection && MouseReleased)
	{
		console.log('pressed on ' + Selection);
		WSSendMessage("c" + Selection);
	}
}


function DrawGroupMenu()
{
	var context = CanvasDetailedView.getContext('2d');
	var nColorIndex = 0;
	var Selection = null;
	var SizeInfo = GroupMenuSize();
	var Y = SizeInfo.y;
	var X = SizeInfo.x;
	var Width = SizeInfo.w;

	function DrawMenuElement(Selected, Name, color, Indent)
	{
		var bMouseIn = MouseY >= Y && MouseY < Y + BoxHeight;
		var bgcolor = bMouseIn ? nBackColorOffset : nBackColors[nColorIndex];
		if(Selected)
		{
			context.fillStyle = 'white';
			context.fillRect(X-2, Y, Width+4, BoxHeight);
		}
		context.fillStyle = bgcolor;
		context.fillRect(X, Y, Width, BoxHeight);
		context.fillStyle = color;
		if(!Indent) Indent = 0;
		context.fillText(Name, X + Indent*FontWidth, Y+BoxHeight-FontAscent);
		nColorIndex = 1-nColorIndex;
		Y += BoxHeight;
		return bMouseIn;
	}
	function DrawMenuRecursive(Index, Indent)
	{
		ProfileEnter("DrawMenuRecursive");		
		var v = TimerArray[Index];
		if(v.idtype == TYPE_TIMER)
		{
			return;
		}
		var Closed = 0;
		if(Index > 0)
		{
			if(DrawMenuElement(v.e, v.name, v.color, Indent))
			{
				Selection = v.id;
			}
		}

		if(!Closed)
		{
			var ChildIndex = v.firstchild;
			while(ChildIndex)
			{
				DrawMenuRecursive(ChildIndex, Indent + 1);
				ChildIndex = TimerArray[ChildIndex].sibling;
			}
		}
		ProfileLeave();
	}
	DrawMenuRecursive(0, -1);
	if(Selection && MouseReleased)
	{
		console.log('pressed on ' + Selection);
		WSSendMessage("c" + Selection);
	}
}


function DrawMenu()
{
	if(WSConnected && WS && WS.readyState == 1)
	{
		var context = CanvasDetailedView.getContext('2d');
		var nColorIndex = 0;
		var Y = 50;
		var Width = 300;
		var Selection = null;
		ProfileEnter("DrawMenu");
		DrawTopMenu();

		if(SubMenuActive == SubMenuGroup)
		{
			DrawGroupMenu();
		}
		else if(SubMenuActive == SubMenuTimers)
		{
			DrawTimerMenu();
		}
		else if(SubMenuActive == SubMenuSettings)
		{
			DrawSettingsMenu();
		}
		ProfileLeave();
	}
}

function DrawConnectionStatus()
{
	if(WSConnected && WS && WS.readyState == 1)
	{
		if(!ProfileMode)
			return;
	}
	var Strings = new Array();
	Strings.push("Status");
	if(WSConnected && WS && WS.readyState == 1)
	{
		Strings.push("[X]");
	}
	else
	{
		ConnectionIdx = (ConnectionIdx + 1 ) % ConnectionStr.length;
		Strings.push("[" + ConnectionStr[ConnectionIdx]+"]");
	}
	Strings.push("Port");
	Strings.push("" + WSPort);
	Strings.push("Path");
	Strings.push("" + WSPath);
	Strings.push("Sends");
	Strings.push("" + WSSend);
	Strings.push("Receives");
	Strings.push("" + WSReceive);
	Strings.push("SendBytes");
	Strings.push("" + WSSendBytes);
	Strings.push("ReceiveBytes");
	Strings.push("" + WSReceiveBytes);
	Strings.push("Seconds");
	Strings.push("" + WSSeconds);


	DrawToolTip(Strings, CanvasDetailedView, 50000, 0);

}
function Draw()
{
	ProfileModeClear();
	ProfileEnter("Total");
	DrawViews();
	DrawMenu();
	DrawConnectionStatus();
	DrawPlotf(CanvasDetailedView);
	ProfileLeave();
	ProfileModeDraw(CanvasDetailedView);

	MouseReleased = false;
}
function RequestDraw()
{
}

function AutoRedraw(Timestamp)
{
	Draw();
	PlotfClear();
	requestAnimationFrame(AutoRedraw);
}




function WSOpen()
{
	WSSend = 0;
	WSReceive = 0;
	WSSendBytes = 0;
	WSReceiveBytes = 0;

	TimerArray = [];
	TimerArray.push(Empty);
	WidthArray = [];
	WidthArray[TYPE_NONE] = 0;
	WidthArray[TYPE_TIMER] = 0;
	WidthArray[TYPE_GROUP] = 0;
	WidthArray[TYPE_CATEGORY] = 0;
	WidthTree = FontWidth;

	ResetFrameData();

	console.log('socket is OPEN!! path ' + WSPath);
}

function SplitIdTop(v)
{
	return v >> 24; // todo: verify
}

function SplitIdBottom(v)
{
	return v & 0xffffff; // todo: verify
}

function GetTimer(id)
{
	for(var i = 0; i < TimerArray.length; ++i)
	{
		if(TimerArray[i].id == id)
		{
			return i;
		}
	}
	return null;
}
function EnableTimer(T)
{
	var idx = GetTimer(T.id);
	if(idx>=0)
	{
		TimerArray[idx].e = T.e;
		console.log('tenable ', TimerArray[idx].idtype, " ", TimerArray[idx].idelement, " ", TimerArray[idx].e);
	}
	else
	{
		console.log('unknown enable message');
	}
}
function MeasureWidth(str)
{
	var context = CanvasDetailedView.getContext('2d');
	return context.measureText(str).width;
}
function AddTimer(T)
{
	var idx = TimerArray.length;
	var existing = GetTimer(T.id);
	if(existing)
	{
		idx = existing;
	}
	TimerArray[idx] = T;
	var w = MeasureWidth(T.name);
	var idtype = SplitIdTop(T.id);
	TimerArray[idx].idtype = idtype;
	TimerArray[idx].idelement = SplitIdBottom(T.id);
	TimerArray[idx].w = w;
	TimerArray[idx].wtree = w;
	if(w > WidthArray[idtype])
	{
		WidthArray[idtype] = w;
	}

	var pidx = GetTimer(T.pid);
	if(pidx >= 0)
	{
		TimerArray[idx].pidx = pidx;
		var Parent = TimerArray[pidx];
		var Sibling = Parent.firstchild;
		Parent.firstchild = idx;
		TimerArray[idx].sibling = Sibling;
		TimerArray[idx].wtree += Parent.depth * FontWidth;
		TimerArray[idx].depth = Parent.depth + 1;
		if(TimerArray[idx].wtree > WidthTree)
		{
			WidthTree = TimerArray[idx].wtree;
		}
	}
	else
	{
		debugger;//fail
	}
	console.log('add timer ' + idx + ' parent ' + pidx);
	RequestDraw();

}

function AllocClearedArray(Size)
{
	var A = new Array(Size);
	for(var i = 0; i < Size; ++i)
	{
		A[i] = 0;
	}
	return A;
}
function PushIntoArray(A, v)
{
	A.shift();
	A.push(v);
}
function ResetFrameData()
{
	FrameData = {};
	FrameData.TimerMap = {};
	FrameData.Time = AllocClearedArray(FrameCount);
	FrameData.Ids = AllocClearedArray(FrameCount);
}
function GetFrameData(id)
{
	if(FrameData.TimerMap[id])
	{
		return FrameData.TimerMap[id];
	}
	else
	{
		var FD = {};
		FD.Count = AllocClearedArray(FrameCount);
		FD.Time = AllocClearedArray(FrameCount);
		FD.TimeExcl = AllocClearedArray(FrameCount);
		FD.FrameTime = 0.0;
		FD.AggregateTime = 0.0;
		FrameData.TimerMap[id] = FD;
		return FD;
	}
}

function ProcessFrame(F)
{
	PushIntoArray(FrameData.Time, F.t);
	PushIntoArray(FrameData.Ids, F.f);
	for(var idx in F.x)
	{
		var FD = GetFrameData(idx);
		var Data = F.x[idx];
		PushIntoArray(FD.Time, Data[0]);
		PushIntoArray(FD.TimeExcl, Data[1]);
		PushIntoArray(FD.Count, Data[2]);
	}
	for(var idx in FrameData.TimerMap)
	{
		FD = FrameData.TimerMap[idx];
		if(!F.x[idx])
		{
			PushIntoArray(FD.Time,0.0);
			PushIntoArray(FD.TimeExcl, 0.0);
			PushIntoArray(FD.Count, 0);
		}
		FD.FrameTime = FD.Time[FD.Time.length-1];
		FD.AggregateTime = FD.Time[FD.Time.length-1];

	}
	FramePending++;
}

function WSMessage()
{
//	console.log(event.data);
	var Obj = JSON.parse(event.data);
	WSReceive++;
	WSReceiveBytes += event.data.length;
	var k = Obj.k;
	if(k == MSG_TIMER_TREE)
	{
		AddTimer(Obj.v);
	}
	else if(k == MSG_ENABLED)
	{
		console.log('got enable message ' + event.data);
		EnableTimer(Obj.v);
	}
	else if(k == MSG_FRAME)
	{
		//console.log('frame message');
		ProcessFrame(Obj.v);
	}
}
function WSError()
{
	console.log('WSError');
}
function WSClose()
{
	console.log('WSClose');
}
function WSSendMessage(msgid)
{
	if(WSConnected)
	{
		var str = '' + msgid;
		WSSend++;
		WSSendBytes += str.length;
		WS.send(str);
	}
}


function Connect()
{
	if(WS && (WS.readyState == 1 || WS.readyState == 0))
	{
		WSConnected = WS.readyState == 1;
		WSFail = 0;
		WSSeconds = 0;
	}
	else
	{
		WSConnected = 0;
		WSSeconds = (new Date() - WSOpenTime);
		if(!WS || WSSeconds > 2000)
		{
			// WSPort++;
			// if(WSPort > 1338+2)
			// {
			// 	WSPort = 1338;
			// }
			if(WS)
			{
				WS.close();
				WS = null;
			}
			WSOpenTime = new Date();
			WSPath = "ws://localhost:" + WSPort + "/ws";
			console.log('connecting to ' + WSPath);
			WS = new WebSocket(WSPath);
			WS.onopen = WSOpen;
			WS.onmessage = WSMessage;
			WS.onerror = WSError;
			WS.onclose = WSClose;
			WSFail = 0;
		}
		else
		{
			WSFail++;
		}
	}
}


function MouseMove(evt)
{
    evt.preventDefault();
 //    ZoomActive = 0;
 //    MouseDrag(MouseDragMove, evt);
 // 	MouseHistory = 0;
	// MouseDetailed = 0;
	// HistoryViewMouseX = HistoryViewMouseY = -1;
	var rect = evt.target.getBoundingClientRect();
	var x = evt.clientX - rect.left;
	var y = evt.clientY - rect.top;
	MouseX = x;
	MouseY = y;


	// if(evt.target == CanvasDetailedView)
	// {
	// 	if(!MouseDragSelectRange())
	// 	{
	// 		RangeCpu = RangeInit();
	// 	}
	// }
	// else if(evt.target = CanvasHistory)
	// {
	// 	var Rect = CanvasHistory.getBoundingClientRect();
	// 	HistoryViewMouseX = x;
	// 	HistoryViewMouseY = y;
	// }
	// Draw(1);
	//Draw();
}

function MouseButton(bPressed, evt)
{
    evt.preventDefault();
    MouseReleased = !bPressed;
	// MouseDrag(bPressed ? MouseDragDown : MouseDragUp, evt);
	// if(!bPressed)
	// {
	// 	if(SortColumnMouseOverNext)
	// 	{
	// 		if(SortColumnMouseOverNext == SortColumnMouseOver)
	// 		{
	// 			SortColumnOrderFlip =  1 - SortColumnOrderFlip;
	// 		}
	// 		else
	// 		{
	// 			SortColumnOrderFlip = 0;
	// 		}

	// 		SortColumnMouseOver = SortColumnMouseOverNext;
	// 		SortColumnMouseOverNext = null;
	// 		if(SortColumnMouseOver == StrAverage)
	// 		{
	// 			SortColumn = 1;
	// 		}
	// 		else if(SortColumnMouseOver == StrMax)
	// 		{
	// 			SortColumn = 2;
	// 		}
	// 		else if(SortColumnMouseOver == StrTotal)
	// 		{
	// 			SortColumn = 3;
	// 		}			
	// 		else if(SortColumnMouseOver == StrMin)
	// 		{
	// 			SortColumn = 4;
	// 		}
	// 		else if(SortColumnMouseOver == StrSpike)
	// 		{
	// 			SortColumn = 5;
	// 		}
	// 		else if(SortColumnMouseOver == StrCallAverage)
	// 		{
	// 			SortColumn = 6;
	// 		}
	// 		else if(SortColumnMouseOver == StrCount)
	// 		{
	// 			SortColumn = 7;
	// 		}
	// 		else if(SortColumnMouseOver == StrExclAverage)
	// 		{
	// 			SortColumn = 8;
	// 		}
	// 		else if(SortColumnMouseOver == StrExclMax)
	// 		{
	// 			SortColumn = 9;
	// 		}
	// 		else if(SortColumnMouseOver == StrGroup)
	// 		{
	// 			SortColumn = 0;
	// 		}
	// 		RequestRedraw();
	// 	}
	// }
}

function MouseOut(evt)
{
	// MouseDrag(MouseDragOff, evt);
	// KeyCtrlDown = 0;
	// KeyShiftDown = 0;
	// MouseDragButton = 0;
	// nHoverToken = -1;
	// RangeCpu = RangeInit();
}

function MouseWheel(e)
{
//     var e = window.event || e;
//     var delta = (e.wheelDelta || e.detail * (-120));
//     ZoomGraph((-4 * delta / 120.0) | 0);
//     Draw(1);
}

function KeyUp(evt)
{
	var k = evt.keyCode;
	console.log('keyup ' + k);
	if(k == 220)
	{
		ProfileMode = !ProfileMode;
	}
	if(k == 27)
	{
		if(FilterInput.value.trim() != "")
		{
			FilterInput.value = "";
		}
		else
		{
			ToggleSubMenu(-1);
		}
	}
	if(k == 191)
	{
		WSPort++;
		if(WSPort > 1338+2)
		{
			WSPort = 1338;
		}
		if(WS)
		{
			WS.close();
			WS = null;
		}
	}
	if(k == 32)
	{
		WSSendMessage("f");
	}
	// if(evt.keyCode == 39)
	// {
	// 	MoveToNext(1);
	// }
	// if(evt.keyCode == 37)
	// {
	// 	MoveToNext(-1);
	// }
	// if(evt.keyCode == 17)
	// {
	// 	KeyCtrlDown = 0;
	// 	MouseDragKeyUp();
	// }
	// else if(evt.keyCode == 16)
	// {
	// 	KeyShiftDown = 0;
	// 	MouseDragKeyUp();
	// }
	// if(evt.keyCode == 32)
	// {
	// 	if(RangeSelect.Begin < RangeSelect.End)
	// 	{
	// 		ZoomTo(RangeSelect.Begin, RangeSelect.End);
	// 		RangeSelect = RangeInit();
	// 		MouseHandleDragEnd();
	// 	}
	// }
	// if(evt.keyCode == 9)
	// {
	// 	evt.preventDefault();
	// 	if(Mode == ModeDetailed)
	// 	{
	// 		var Token = nHoverToken;
	// 		if(Token == -1 && RangeValid(RangeSelect) && RangeSelect.Index >= 0)
	// 		{
	// 			Token = RangeSelect.Index;
	// 		}
	// 		if(Token != -1 && Token < TimerInfo.length)
	// 		{
	// 			var start = TimerInfo[Token].worststart;
	// 			var end = TimerInfo[Token].worstend;
	// 			RangeSelect.Begin = start;
	// 			RangeSelect.End = end;
	// 			RangeSelect.Thread = TimerInfo[Token].worstthread;
	// 			RangeSelect.Index = Token;
	// 			ShowFlashMessage('Worst: ' + (end-start).toFixed(2) + 'ms', 100);
	// 			MoveTo(RangeSelect.Begin, RangeSelect.End, ThreadY[RangeSelect.Thread] + nOffsetY, ThreadY[RangeSelect.Thread+1] + nOffsetY);
	// 			MouseHandleDragEnd();
	// 		}
	// 	}
	// 	else if(Mode == ModeTimers)
	// 	{
	// 		ToggleFilterInput(0);
	// 		evt.preventDefault();
	// 	}

	// }
	// if(evt.keyCode == 27)
	// {
	// 	RangeSelect = RangeInit();
	// 	SortColumn = 0;
	// 	SortColumnMouseOver = "";
	// 	if(Mode == ModeTimers)
	// 	{
	// 		ToggleFilterInput(1);
	// 		evt.preventDefault();
	// 	}
	// }

	// if(evt.keyCode == 18 || evt.keyCode == 90) // z/tab to toggle tooltip
	// {
	// 	ToolTip = (ToolTip+1)%3; //0: off, 1: default, 2: flipped
	// 	var ToolTipStr = 'Off';
	// 	var bShowTimers = Mode == ModeTimers;
	// 	if(ToolTip == 2)
	// 	{
	// 		bShowTimers = !bShowTimers;
	// 	}
	// 	if(ToolTip)
	// 	{
	// 		if(bShowTimers)
	// 			ToolTipStr = "Timers";
	// 		else
	// 			ToolTipStr = "Detailed";
	// 	}
	// 	ShowFlashMessage('ToolTip: ' + ToolTipStr, 100);
	// }


	// Invalidate = 0;
}

function KeyDown(evt)
{
	// if(evt.keyCode == 17)
	// {
	// 	KeyCtrlDown = 1;
	// }
	// else if(evt.keyCode == 16)
	// {
	// 	KeyShiftDown = 1;
	// }
	// else if(evt.keyCode == 9)
	// {
	// 	evt.preventDefault();
	// }
	// Invalidate = 0;
}


function SetupEvents()
{
	var mousewheelevt = (/Firefox/i.test(navigator.userAgent)) ? "DOMMouseScroll" : "mousewheel" //FF doesn't recognize mousewheel as of 
	CanvasDetailedView.addEventListener('mousemove', MouseMove, false);
	CanvasDetailedView.addEventListener('mousedown', function(evt) { MouseButton(true, evt); });
	CanvasDetailedView.addEventListener('mouseup', function(evt) { MouseButton(false, evt); } );
	CanvasDetailedView.addEventListener('mouseout', MouseOut);
	CanvasDetailedView.addEventListener("contextmenu", function (e) { e.preventDefault(); }, false);
	CanvasDetailedView.addEventListener(mousewheelevt, MouseWheel, false);
	// FilterInputTimer.addEventListener('keyup', FilterKeyUp);
	// FilterInputGroup.addEventListener('keyup', FilterKeyUp);
	window.addEventListener('keydown', KeyDown);
	window.addEventListener('keyup', KeyUp);
	window.addEventListener('resize', ResizeCanvas, false);
}

function DrawToolTip(StringArray, Canvas, x, y)
{
	var context = Canvas.getContext('2d');
	context.font = Font;
	var WidthArray = Array(StringArray.length);
	var nMaxWidth = 0;
	var nHeight = 0;
	for(var i = 0; i < StringArray.length; i += 2)
	{
		var nWidth0 = context.measureText(StringArray[i]).width;
		var nWidth1 = context.measureText(StringArray[i+1]).width;
		var nSum = nWidth0 + nWidth1;
		WidthArray[i] = nWidth0;
		WidthArray[i+1] = nWidth1;
		if(nSum > nMaxWidth)
		{
			nMaxWidth = nSum;
		}
		nHeight += BoxHeight;
	}
	nMaxWidth += 15;
	//bounds check.
	var CanvasRect = Canvas.getBoundingClientRect();
	if(y + nHeight > CanvasRect.height)
	{
		y = CanvasRect.height - nHeight;
		x += 20;
	}
	if(x + nMaxWidth > CanvasRect.width)
	{
		x = CanvasRect.width - nMaxWidth;
	}

	context.fillStyle = 'black';
	context.fillRect(x-1, y, nMaxWidth+2, nHeight);
	context.fillStyle = 'white';

	var XPos = x;
	var XPosRight = x + nMaxWidth;
	var YPos = y + BoxHeight-2;
	for(i = 0; i < StringArray.length; i += 2)
	{
		context.fillText(StringArray[i], XPos, YPos);
		context.fillText(StringArray[i+1], XPosRight - WidthArray[i+1], YPos);
		YPos += BoxHeight;
	}
}

function DrawPlotf(Canvas)
{
	return;
	var context = Canvas.getContext('2d');
	context.font = Font;
	var WidthArray = Array(PlotfArray.length);
	var nMaxWidth = 0;
	var nHeight = 0;

	context.font = Font;
	for(i = 0; i < PlotfArray.length; i++)
	{
		var nWidth = context.measureText(PlotfArray[i]).width;
		WidthArray[i] = nWidth;
		if(nWidth > nMaxWidth)
		{
			nMaxWidth = nWidth;
		}
		nHeight += BoxHeight;
	}
	nMaxWidth += 15;
	var x = 0;
	var y = 0;

	context.fillStyle = 'black';
	context.fillRect(x-1, y, nMaxWidth+2, nHeight);
	context.fillStyle = 'white';

	var XPos = x;
	var XPosRight = x + nMaxWidth;
	var YPos = y + BoxHeight-2;
	for(i = 0; i < PlotfArray.length; i++)
	{
		context.fillText(PlotfArray[i], XPos, YPos);
		YPos += BoxHeight;
	}
}

ResizeCanvas();
SetupEvents();
InitMenu();

setInterval(Connect, 10);



//Draw();
AutoRedraw();


</script>
</body>
</html>      


