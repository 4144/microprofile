<!DOCTYPE HTML>
<html>
<head>
<title>MicroProfile Capture</title>
<style>
/* about css: http://bit.ly/1eMQ42U */
body {margin: 0px;padding: 0px; font: 12px Courier New;background-color:#474747; color:white;overflow:hidden;}
ul {list-style-type: none;margin: 0;padding: 0;}
li{display: inline; float:left;border:5px; position:relative;text-align:center;}
a {
    float:left;
    text-decoration:none;
    display: inline;
    text-align: center;
	padding:5px;
	padding-bottom:0px;
	padding-top:0px;
    color: #FFFFFF;
    background-color: #474747;
}
a:hover, a:active{
	background-color: #000000;
}

ul ul {
    position:absolute;
    left:0;
    top:100%;
    margin-left:-999em;
}
li:hover ul {
    margin-left:0;
    margin-right:0;
}
ul li ul{ display:block;float:none;width:100%;}
ul li ul li{ display:block;float:none;width:100%;}
li li a{ display:block;float:none;width:100%;text-align:left;}
#nav li:hover div {margin-left:0;}
.help {position:absolute;z-index:5;text-align:left;padding:2px;margin-left:-999em;background-color: #313131;width:300px;}
.helpstart {position:absolute;z-index:5;text-align:left;padding:2px;background-color: #313131;width:300px;display:none}
.root {z-index:1;position:absolute;top:0px;left:0px;}
.filterinput0{position:fixed; background-color: #313131;display:none;}
.filterinput{width:100px;}
</style>
</head>
<body style="">
<div class="filterinput0" id="FilterInputDiv">Filter<br><input type="text" id="FilterInput" class="filterinput"></div>
<canvas id="DetailedView" height="100%" style="background-color:#474747;margin:0px;padding:0px;"></canvas>
<script>
"use strict"


//todo
//Features missing:
//tooltips
//mountain graphs
//bars


//fixes:
// socket crash on chrome shutdown
//fix leaking on load/save
//print stack depths

//improvements:
// on demand redraw
// less cpu when idle
// send frozen state to fix frozen text






var FRAME_HISTORY_COLOR_CPU = '#ff7f27';
var FRAME_HISTORY_COLOR_GPU = '#ffffff';

var Settings = {};

var HistoryHeight = 100;
var CanvasDetailedView = document.getElementById('DetailedView');
var CanvasDetailedOffscreen = document.createElement('canvas');
var FilterInput = document.getElementById('FilterInput');
var FilterInputDiv = document.getElementById('FilterInputDiv');
var FilterInputDivPos = {"x":-1,"y":-1,"w":-1,"h":-1};

var CanvasArray0 = [];
var CanvasArray1 = [];
var Views = [];

var nWidth = CanvasDetailedView.width;
var nHeight = CanvasDetailedView.height;
var nBackColors = ['#474747', '#313131' ];
var nBackColorOffset = '#606060';
var FontHeight = 10;
var FontWidth = 1;
var FontAscent = 3; //Set manually
var Font = 'Bold ' + FontHeight + 'px Courier New';
var FontFlash = 'Bold ' + 35 + 'px Courier New';
var BoxHeight = FontHeight + 2;
var MouseX = 0;
var MouseY = 0;
var MouseReleased = false;

var MouseDragOff = 0;
var MouseDragDown = 1;
var MouseDragUp = 2;
var MouseDragMove = 3;
var MouseDragState = MouseDragOff;
var MouseDragTarget = 0;
var MouseDragButton = 0;
var MouseDragKeyShift = 0;
var MouseDragKeyCtrl = 0;
var MouseDragX = 0;
var MouseDragY = 0;
var MouseDragXLast = 0;
var MouseDragYLast = 0;
var MouseDragXStart = 0;
var MouseDragYStart = 0;

var MouseDragActiveXStart = 0;
var MouseDragActiveXEnd = -1;

var ToolTipCallback = null;

var DPR = 0;
var C_HUGE = 1e10;

var ActivePreset = "Default";
var Presets = [];

Settings.ReferenceTime = 50.0;
var ReferencePresets = [5.0, 10.0, 15.0, 20, 30, 33.33, 50, 66.66,100.0,250.0,500,1000.0];
var ReferenceTimeTweak = -1;

Settings.TargetTime = 30;
var TargetTimeTweak = -1;


var AggregateFrames = 60;
Settings.AggregateFrames = 60;
var AggregatePresets = [-1, 10,20,30,60,90,120,500];
var AggregateHistorySize = 5;
var AggregateTweak = -1;

var AutoCaptureEnabled = 0;
var AutoCaptureDefaultThreshold = 66;
Settings.AutoCaptureTheshold = AutoCaptureDefaultThreshold;
var AutoCaptureThesholdPresets = [1,3,5,10,15,30,50,66,90,100,250,500,1000];
var AutoCaptureTweak = -1;
var AutoCaptureSourceTweak = -1;
var AutoCaptureSourceIndex = -1;

var CaptureFramesDefault = 30;
Settings.CaptureFrames = CaptureFramesDefault;
var CaptureFramesPresets = [5,10,15,30,50,66,90,100];
var CaptureTweak = -1;


var ProfileData = {};
var ProfileStackTime = {};
var ProfileStackName = {};
var ProfileMode = 0;
var ProfileRedraw0 = 0;
var ProfileRedraw1 = 0;
var ProfileRedraw2 = 0;
var ProfileFps = 0;
var ProfileFpsAggr = 0;
var ProfileFpsCount = 0;
var ProfileLastTimeStamp = new Date();
var PlotfArray = new Array();

var ConnectionStr = ["x", "|", "x", "-" ];
var ConnectionIdx = 0;
var EnabledArray = [];


var FrameData = {};
var FrameCount = 256;
var FramePending = 0;

var WSConnected = 0;
var WSSeconds = 0;
var WSFail = 0;
var WS;
var WSHost = location.hostname ? location.hostname : "localhost";
var WSPort = location.port?location.port : 1338;
var WSPath;

var CaptureButtonX = 0;
var CaptureButtonY = 0;


var MSG_TIMER_TREE = 1;
var MSG_ENABLED = 2;
var MSG_FRAME = 3;
var MSG_LOADSETTINGS = 4; 
var MSG_PRESETS = 5;

var TYPE_NONE = 0;
var TYPE_TIMER = 1;
var TYPE_GROUP = 2;
var TYPE_CATEGORY = 3;


var WSSend = 0;
var WSReceive = 0;
var WSSendBytes = 0;
var WSReceiveBytes = 0;
var WSOpenTime = 0;


var TimerArray = [];
var Empty = {"id":0, "w":0, "depth":0};
var WidthArray = [];
var WidthTree = 0;
Settings.ViewActive = 0;
var ViewNames = ["Graph", "Bar Time[all]", "Multi Bar[all]", "Multi Bar[single]"];

var SingleTimerBars = 0;
var History;
var MainView;
var X5Views;


var KeyShiftDown = 0;
var KeyCtrlDown = 0;

var IsFrozen = 0;

TimerArray.push(Empty); // 0 is root of tree



function Plotf(str)
{
	PlotfArray.push(str)
}
function PlotfClear()
{
	PlotfArray = new Array();
}

function ProfileModeClear()
{
	if(ProfileMode)
	{
		ProfileData = new Object();
		ProfileStackTime = new Array();
		ProfileStackName = new Array();
	}
}
function ProfileEnter(Name)
{
	if(ProfileMode)
	{
		ProfileStackTime.push(new Date());
		ProfileStackName.push(Name);
	}
}
function ProfileLeave()
{
	if(ProfileMode)
	{
		var Time = new Date();
		var Delta = Time - ProfileStackTime.pop();
		var Name = ProfileStackName.pop();
		var Obj = ProfileData[Name];
		if(!Obj)
		{
			Obj = new Object();
			Obj.Count = 0;
			Obj.Name = Name;
			Obj.Time = 0;
			ProfileData[Name] = Obj;
		}
		Obj.Time += Delta;
		Obj.Count += 1;
	}
}

function ProfilePlot(s)
{
	if(ProfileMode)
	{
		var A = ProfileData.Plot;
		if(!A)
		{
			ProfileData.Plot = Array();
			A = ProfileData.Plot;
		}
		if(A.length<10)
		{
			A.push(s);
		}
	}
}
function ProfileModeDump()
{
	for(var idx in ProfileData)
	{
		var Timer = ProfileData[idx];
		console.log(Timer.Name + " " + Timer.Time + "ms " + Timer.Count);
	}

}
function ProfileModeDraw(Canvas)
{
	if(ProfileMode)
	{
		var StringArray = [];
		for(var idx in ProfileData)
		{
			if(idx == "Plot")
				continue;
			var Timer = ProfileData[idx];
			StringArray.push(Timer.Name);
			StringArray.push(Timer.Time + "ms");
			StringArray.push("#");
			StringArray.push("" + Timer.Count);
		}
		// StringArray.push("debug");
		// StringArray.push(Debug);
		var Time = new Date();
		var Delta = Time - ProfileLastTimeStamp;
		ProfileLastTimeStamp = Time;
		StringArray.push("Frame Delta");
		StringArray.push(Delta + "ms");
		if(ProfileMode == 2)
		{
			ProfileFpsAggr += Delta;
			ProfileFpsCount ++ ;
			var AggrFrames = 10;
			if(ProfileFpsCount == AggrFrames)
			{
				ProfileFps = 1000 / (ProfileFpsAggr / AggrFrames);
				ProfileFpsAggr = 0;
				ProfileFpsCount = 0;
			}
			StringArray.push("FPS");
			StringArray.push("" + ProfileFps.toFixed(2));
		}
		for(var i = 0; i < ProfileData.Plot; ++i)
		{
			StringArray.push("");
			StringArray.push(ProfileData.Plot[i]);
		}
		ProfileData.Plot = Array();
		DrawToolTip(StringArray, Canvas, 0, 200);
	}
}



function MeasureFont()
{
	var context = CanvasDetailedView.getContext('2d');
	//context.font = Font;
	FontWidth = context.measureText('W').width;

}
function ResizeCanvasDPR(w, h, c)
{
	DPR = window.devicePixelRatio;
	if(DPR)
	{
		c.style.width = w + 'px'; 
		c.style.height = h + 'px';
		c.width = w * DPR;
		c.height = h * DPR;
		c.getContext('2d').scale(DPR,DPR);
	}
	else
	{
		c.width = w;
		c.height = h;
	}

}

function ResizeCanvasDPR2(w, h, c)
{
	DPR = window.devicePixelRatio;
	if(DPR)
	{
		c.style.width = w + 'px'; 
		c.style.height = h + 'px';
		c.width = w * DPR;
		c.height = h * DPR;
		c.getContext('2d').scale(DPR,DPR);
	}
	else
	{
		c.width = w;
		c.height = h;
	}

}
function CreateView(x, y, w, h, name, DisplayFunc, visible, index)
{
	var idx = Views.length;
	var c0 = CanvasArray0[idx];
	var c1 = CanvasArray1[idx];
	if(!c0)
	{
		c0 = document.createElement('canvas');
		CanvasArray0[idx] = c0;
	}
	if(!c1)
	{
		c1 = document.createElement('canvas');
		CanvasArray1[idx] = c1;
	}
	var View = {};
	View.x = x;
	View.y = y;
	View.w = w;
	View.h = h;
	View.Canvas = [c0, c1];
	View.OffscreenData = [null, null];
	View.visible = visible;
	View.index = index;
	ResizeCanvasDPR(w, h, c0);
	ResizeCanvasDPR(w, h, c1);

	c0.getContext('2d').clearRect(0, 0, w, h);
	c1.getContext('2d').clearRect(0, 0, w, h);
	View.OffscreenData[0] = c0.getContext('2d').getImageData(0, 0, c0.width, c0.height);
	View.OffscreenData[1] = c1.getContext('2d').getImageData(0, 0, c1.width, c1.height);
	View.BackBuffer = 0;
	View.DisplayFunc = DisplayFunc;
	Views.push(View);
	return View;
}

function CreateViews(Width, Height)
{
	Views = [];
	History = CreateView(0, 0, Width, HistoryHeight, "History", DrawHistory, true, 0);
	MainView = CreateView(0, HistoryHeight, Width, Height-HistoryHeight, "Main", DrawGraph, true);
	X5Views = [];
	var w = Width / 7;
	var x = 0;
	X5Views.push(CreateView(w*0, HistoryHeight, w, Height - HistoryHeight, "x5_0", DrawBars, false, 0) );
	X5Views.push(CreateView(w*1, HistoryHeight, w, Height - HistoryHeight, "x5_1", DrawBars, false, 1) );
	X5Views.push(CreateView(w*2, HistoryHeight, w, Height - HistoryHeight, "x5_2", DrawBars, false, 2) );
	X5Views.push(CreateView(w*3, HistoryHeight, w, Height - HistoryHeight, "x5_3", DrawBars, false, 3) );
	X5Views.push(CreateView(w*4, HistoryHeight, w, Height - HistoryHeight, "x5_4", DrawBars, false, 4) );
	X5Views.push(CreateView(w*5, HistoryHeight, w, Height - HistoryHeight, "x5_3", DrawBars, false, 5) );
	X5Views.push(CreateView(w*6, HistoryHeight, w, Height - HistoryHeight, "x5_3", DrawBars, false, 6) );

}

function ResizeCanvas() 
{
	nWidth = window.innerWidth;
	nHeight = window.innerHeight;
	DPR = window.devicePixelRatio;
	ResizeCanvasDPR(nWidth, nHeight, CanvasDetailedView);
	ResizeCanvasDPR(nWidth, nHeight, CanvasDetailedOffscreen);

	if(DPR)
	{
		CanvasDetailedView.style.width = nWidth + 'px'; 
		CanvasDetailedView.style.height = nHeight + 'px';
		CanvasDetailedView.width = nWidth * DPR;
		CanvasDetailedView.height = nHeight * DPR;
		CanvasDetailedView.getContext('2d').scale(DPR,DPR);

		CanvasDetailedOffscreen.style.width = nWidth + 'px';
		CanvasDetailedOffscreen.style.height = nHeight + 'px';
		CanvasDetailedOffscreen.width = nWidth * DPR;
		CanvasDetailedOffscreen.height = nHeight * DPR;
		CanvasDetailedOffscreen.getContext('2d').scale(DPR,DPR);

	}
	else
	{
		DPR = 1;
		CanvasDetailedView.width = nWidth;
		CanvasDetailedView.height = nHeight;
		CanvasDetailedOffscreen.width = nWidth;
		CanvasDetailedOffscreen.height = nHeight;
	}
	MeasureFont();
	CreateViews(nWidth, nHeight);
}


function FormatTime(Time)
{
	return Time.toFixed(2);
}
var hh = 0;

function DrawBars(View, LocalMouseX, LocalMouseY, SubIndex)
{
	var TimerMap = FrameData.TimerMap;
	if(!TimerMap)
		return;
	if(!SubIndex)
		SubIndex = 0;

	ProfileEnter("DrawBar");
	var Canvas = View.Canvas[View.BackBuffer];
	var context = Canvas.getContext('2d');
	context.clearRect(0, 0, View.w, View.h);

	var Title = "?";
	var TitleName = null;
	var nNumBars = 0;
	var BarNames = [];
	var BarTimes = [];
	var BarColors = [];
	var AggregateIndex = Settings.ReferenceTime < 0 ? AggregateHistorySize-1 : AggregateHistorySize-2; //fix med 
	var GetTime = null;

	if(SingleTimerBars == 0)
	{
		if(SubIndex == 0)
		{
			Title = "Time";
			GetTime = function(FD){ return FD.FrameTime; };
		}
		else if(SubIndex == 1)
		{
			Title = "Average";
			GetTime = function(FD){ return FD.TimeAvg[AggregateIndex]; };
		}
		else if(SubIndex == 2)
		{
			Title = "Max";
			GetTime = function(FD){ return FD.TimeMax[AggregateIndex]; };
		}
		else if(SubIndex == 3)
		{
			Title = "Min";
			GetTime = function(FD){ return FD.TimeMin[AggregateIndex]; };
		}
		else if(SubIndex == 4)
		{
			Title = "Exclusive Avg";
			GetTime = function(FD){ return FD.TimeExclAvg[AggregateIndex]; };
		}
		else if(SubIndex == 5)
		{
			Title = "Exclusive Max";
			GetTime = function(FD){ return FD.TimeExclMax[AggregateIndex]; };
		}
		else if(SubIndex == 6)
		{
			Title = "Exclusive Min";
			GetTime = function(FD){ return FD.TimeExclMin[AggregateIndex]; };

		}
		for(var key in TimerMap)
		{
			var idx = GetTimer(key);
			var T = TimerArray[idx];
			if(T.e)
			{
				nNumBars++;
				var FD = TimerMap[key];
				var Time = GetTime(FD);
				BarNames.push(T.name);
				BarTimes.push(Time);
				BarColors.push(T.color);
			}
		}

	}
	else if(EnabledArray.length > 0)
	{
		var idx = EnabledArray[0];
		var T = TimerArray[idx];
		var FD =  GetFrameData(T.id);
		var Property = null;
		if(SubIndex == 0)
		{
			Title = "Average";
			Property = "TimeAvg";
		}
		else if(SubIndex == 1)
		{
			Title = "Max";
			Property = "TimeMax";
		}
		else if(SubIndex == 2)
		{
			Title = "Min";
			Property = "TimeMin";
		}
		else if(SubIndex == 3)
		{
			Title = "Exclusive Average";
			Property = "TimeExclAvg";
		}
		else if(SubIndex == 4)
		{
			Title = "Exclusive Max";
			Property = "TimeExclMax"
		}
		else if(SubIndex == 5)
		{
			Title = "Exclusive Min";
			Property = "TimeExclMin"
		}
		else if(SubIndex == 6)
		{
			Title = "Call Average";
			Property = "TimeCallAvg"
		}
		TitleName = T.name;
		for(var i = 0; i < AggregateHistorySize; ++i)
		{
			nNumBars++;
			var A = FD[Property];
			var Time = A[i];
			BarTimes.push(Time);
			BarColors.push(T.color);
		}

	}


	if(!nNumBars)
	{
		ProfileLeave();
		return;
	}

	var h = View.h;
	var w = View.w;
	var DrawX = 25;
	var DrawY = 35;
	var DrawWidth = w -  2 * DrawX;
	var DrawHeight = h - 2 * DrawY;
	var SpaceWidth = 5;
	var BarWidth = (DrawWidth-SpaceWidth*(nNumBars-1))/ nNumBars;
	if(BarWidth > 50)
		BarWidth = 50;
	var BarHeight = DrawHeight - 10;

	var fHeightScale = h / Settings.ReferenceTime;
	var MouseDragging = 0;
	var fWidth = w / FrameCount;
	var Keys = [];
	var X = DrawX;
	var offset = 0;
	context.textAlign = 'center'
	context.fillStyle = '#ffffff';
	context.fillText(Title, w / 2.0, FontHeight);
	if(TitleName)
	{
		context.fillText(TitleName, w / 2.0, DrawY - offset);
	}
	context.textAlign = 'right';

	for(var i = 0; i < BarTimes.length; ++i)
	{
		var Time = BarTimes[i];
		var Color = BarColors[i];
		var fPrc = Time / Settings.ReferenceTime;
		if(fPrc > 1.0)
			fPrc = 1.0
		var BarH = fPrc * BarHeight;

		var X0 = X;
		var Y0 =  DrawX + DrawHeight - BarH;
		context.fillStyle = Color;
		context.fillRect(X0, Y0, BarWidth, BarH);
		context.fillStyle = '#ffffff';
		var TimeText = FormatTime(Time);
		context.fillText(TimeText, X+BarWidth, DrawX+DrawHeight + FontHeight);
		if(!TitleName)
		{
			var Name = BarNames[i];
			context.fillText(Name, X+BarWidth, DrawY - offset);
		}
		X += BarWidth + SpaceWidth;
	}
	ProfileLeave();
}



function DrawGraph(View, LocalMouseX, LocalMouseY, SubIndex)
{
	var TimerMap = FrameData.TimerMap;
	if(!TimerMap)
		return;

	ProfileEnter("DrawGraph");
	var Canvas = View.Canvas[View.BackBuffer];
	var context = Canvas.getContext('2d');
	context.clearRect(0, 0, View.w, View.h);

	var h = View.h;
	var w = View.w;
	var fHeightScale = h / Settings.ReferenceTime;
	var MouseDragging = 0;
	var fWidth = w / (FrameCount);
	var HighlightFrame = -1;

	if(LocalMouseX >= 0 && LocalMouseY >= 0 && LocalMouseX < w && LocalMouseY < h)
	{
		var index = Math.floor(FrameCount * LocalMouseX / w);
		ToolTipCallback = function()
		{
			var StringArray = [];
			var TimerMap = FrameData.TimerMap;
			for(var key in TimerMap)
			{
				var idx = GetTimer(key);
				var T = TimerArray[idx];
				var TimerState = TimerMap[key];
				var Time = TimerState.Time;
				StringArray.push('' + T.name);
				StringArray.push('' + FormatTime(Time[index]) + 'ms') ;
			}
			return StringArray;
		}
		HighlightFrame = index;
	}


	var Keys = [];
	for(var key in TimerMap)
	{
		var idx = GetTimer(key);
		var TimerState = TimerMap[key];
		var Time = TimerState.Time;
		var color = TimerArray[idx].color;
		var X = w - Time.length*fWidth;
		var Y = h;
		context.strokeStyle = color;
		context.fillStyle = color;

		context.beginPath();
		context.moveTo(X,Y);
		for(var i = 0; i < Time.length; ++i)
		{
			Y = h - Time[i] * fHeightScale;
			context.lineTo(X, Y);
			X += fWidth;
		}
		context.stroke();
	}
	if(HighlightFrame >= 0)
	{
		for(var key in TimerMap)
		{
			var idx = GetTimer(key);
			var TimerState = TimerMap[key];
			var Time = TimerState.Time;
			var color = TimerArray[idx].color;
			var X = w - Time.length*fWidth + fWidth * HighlightFrame;
			var Y = h - Time[HighlightFrame] * fHeightScale;
			context.strokeStyle = color;
			context.beginPath();
			var CrossX = X;
			var CrossY = Y;
			context.moveTo(CrossX-2, CrossY-2);
			context.lineTo(CrossX+2, CrossY+2);
			context.moveTo(CrossX+2, CrossY-2);
			context.lineTo(CrossX-2, CrossY+2);
			context.stroke();
		}
	}
	ProfileLeave();
}

function LerpColor(v)
{
	var R_0 = 0;
	var G_0 = 1;
	var B_0 = 0;

	var R_1 = 1;
	var G_1 = 0.5;
	var B_1 = 0;

	var R_2 = 1;
	var G_2 = 0;
	var B_3 = 0;
	var R;
	var G;
	if(v < 0.5)
	{
		v *= 2;
		var v0 = (1-v)
		R = R_0 * v0 + R_1 * v;
		G = G_0 * v0 + G_1 * v;

	}
	else
	{
		v = (v-0.5) * 2;
		var v0 = (1-v)
		R = R_1 * v0 + R_2 * v;
		G = G_1 * v0 + G_2 * v;
	}
	R *= 255;
	G *= 255;
	return "rgb(" + R.toFixed(0) + "," + G.toFixed(0) + ",0)";

}

function DrawRange(context, X, XEnd, Y, YEnd, ColorBack, ColorFront)
{
	if(X < XEnd)
	{
		var W = XEnd - X;
		var H = YEnd - Y;
		context.globalAlpha = 0.1;
		context.fillStyle = ColorBack;
		context.fillRect(X, Y, W, H);
		context.globalAlpha = 1;
		context.strokeStyle = ColorFront;
		context.beginPath();
		context.moveTo(X, 0);
		context.lineTo(X, H);
		context.moveTo(X+W, 0);
		context.lineTo(X+W, H);
		context.stroke();
	}
}

function DrawHistory(View, LocalMouseX, LocalMouseY)
{
	ProfileEnter("DrawHistory");
	var Canvas = View.Canvas[View.BackBuffer];
	var context = Canvas.getContext('2d');
	context.clearRect(0, 0, View.w, View.h);
	if(!FrameData.Time)
		return;
	var fHeight = View.h;
	var fWidth = nWidth / FrameCount;
	var fHeightScale = fHeight / Settings.ReferenceTime;
	var fX = 0;
	var FrameIndex = -1;
	var MouseDragging = 0;
	var GreenTime = (Settings.TargetTime * 0.9);
	var RedBegin = (Settings.TargetTime * 1.1);
	var LerpDist = 1.0 / (RedBegin - GreenTime);
	var id0 = -1;
	var id1 = -1;
	
	if(MouseDragActiveXEnd > MouseDragActiveXStart)
	{
		var idx0 = Math.ceil(FrameCount * MouseDragActiveXStart / nWidth);
		var idx1 = Math.floor(FrameCount * MouseDragActiveXEnd / nWidth);
		idx0 = Clamp(idx0, 0, FrameCount-1);
		idx1 = Clamp(idx1, 0, FrameCount-1);
		id0 = FrameData.Ids[idx0];
		id1 = FrameData.Ids[idx1];
	}


	var ToolTipFrame = -1;
	for(var i = 0; i < FrameCount; i++)
	{
		var fMs = FrameData.Time[i];
		var fPrc = (fMs - GreenTime) * LerpDist;
		fPrc = Clamp(fPrc, 0, 1);
		var color = LerpColor(fPrc);
		var fid = FrameData.Ids[i];
		if(fid >= id0 && fid <= id1)
		{
			color = 'cyan';
		}

		var fH = fHeightScale * fMs;
		var bMouse = LocalMouseX > fX && LocalMouseX < fX + fWidth+1 && MouseY <= HistoryHeight;
		if(bMouse && !MouseDragging)
		{
			context.fillStyle = FRAME_HISTORY_COLOR_GPU;
			ToolTipFrame = i;
		}
		else
		{
			context.fillStyle = color;
		}
		context.fillRect(fX, fHeight - fH, fWidth-1, fH);
		fX += fWidth;
	}


	DrawRange(context, MouseDragActiveXStart, MouseDragActiveXEnd, 0, HistoryHeight, '#59d0ff', '#00ddff');


	var fH = fHeight - fHeightScale * Settings.TargetTime;
	context.fillStyle = 'wheat';
	context.strokeStyle = 'wheat';
	context.beginPath();
	context.moveTo(0, fH);
	context.lineTo(nWidth, fH);
	context.stroke();
	var YText;
	if(fH > HistoryHeight * 0.25)
	{
		YText = fH - FontAscent;
	}
	else
	{
		YText = fH + FontHeight;
	}

	context.fillText(Settings.TargetTime + 'ms', 3, YText);




	if(ToolTipFrame >= 0)
	{
		var fMs = FrameData.Time[ToolTipFrame];
		ToolTipCallback = function()
		{
			var StringArray = [];
			StringArray.push("Frame");
			StringArray.push("" + ToolTipFrame);
			StringArray.push("Time");
			StringArray.push("" + fMs.toFixed(3));
			return StringArray;
		}
	}


	ProfileLeave();

}
function MouseInRect(Rect)
{
	return MouseInside(Rect.x, Rect.y, Rect.w, Rect.h);
}
function MouseInside(X, Y, W, H)
{
	return MouseX >= X && MouseX <= X + W && MouseY >= Y && MouseY <= Y + H;
}

var MessageText = "";
var MessageTimeout = -1;
var MessageTimeoutLast = new Date();
function SetMessage(text, TimeOut)
{
	if(TimeOut)
	{
		MessageTimeout = TimeOut;
	}
	else
	{
		MessageTimeout = -1;
	}
	MessageText = text;
}
function ClearMessage(Message)
{
	if(Message == MessageText)
	{
		MessageText = "";
		MessageTimeout = -1;
	}
}

function DrawMessage(context)
{
	var Now = new Date();
	var Delta = Now - MessageTimeoutLast;
	if(MessageTimeout>0)
	{
		MessageTimeout -= Delta;
		if(MessageTimeout<= 0)
		{
			MessageText = "";
			MessageTimeout = -1;
		}

	}
	MessageTimeoutLast = Now;

	var Text = MessageText;
	var X = nWidth / 2;
	var Y = nHeight / 2;
	context.font = FontFlash;
	context.textAlign = 'center';
	context.fillStyle = 'red';
	context.fillText(Text, X, Y);
	context.textAlign = 'left';
	context.font = Font;
}
function DrawCaptureButton(context)
{

	var CaptureText = "Capture[" + Settings.CaptureFrames + "]";
	var w = 10 + context.measureText(CaptureText).width;
	var X = nWidth / 2 - w / 2;
	var XCenter = nWidth / 2;
	var Y = nHeight - 30;
	var bMouseInCapture = MouseInside(X, Y, w, 4 + FontHeight);
	context.textAlign = 'center';
	context.fillStyle = bMouseInCapture ? nBackColors[1] : 'black';
	context.fillRect(X, Y, w, 4 + FontHeight);
	context.fillStyle = '#ffffff';
	context.fillText(CaptureText, XCenter, Y + FontHeight);


	X += w + 2;
	var MenuText = "^";
	var w2 = 10 + context.measureText(MenuText).width;
	var bMouseInCaptureMenu = MouseInside(X, Y, w2, 4 + FontHeight);
	context.fillStyle = bMouseInCaptureMenu ? nBackColors[1] : 'black';
	context.fillRect(X, Y, w2, 4 + FontHeight);

	context.fillStyle = '#ffffff';
	context.fillText(MenuText, X + w2*0.5, Y + FontHeight);
	context.textAlign = 'left';
	if(MouseReleased)
	{
		if(bMouseInCapture)
		{
			Capture();
		}
	}
	else
	{
		if(bMouseInCaptureMenu)
		{
			CaptureButtonX = X + w2;
			CaptureButtonY = Y;
			EnableMenu(SubMenuCapture);
		}	
	}

}
function DrawViews()
{
	Plotf("DrawViews");
	ProfileEnter("UpdateViews");
	for(var i = 0; i < Views.length; ++i)
	{
		var View = Views[i];
		if(View.visible)
		{
			var LocalMouseX = MouseX - View.x;
			var LocalMouseY = MouseY - View.y;
			View.DisplayFunc(View, LocalMouseX, LocalMouseY, View.index);
			var Canvas = View.Canvas[View.BackBuffer];
			var Context = Canvas.getContext('2d');
		}
	}
	ProfileLeave();
	var context = CanvasDetailedView.getContext('2d');
	context.clearRect(0, 0, nWidth, nHeight);
	ProfileEnter("BlitViews");
	var DPR = window.devicePixelRatio;
	for(var i = 0; i < Views.length; ++i)
	{
		var View = Views[i];
		if(View.visible)
		{
			context.drawImage(View.Canvas[View.BackBuffer], View.x, View.y, View.w, View.h);
		}
	}

	DrawCaptureButton(context);
	DrawMessage(context);

	ProfileLeave();

}
var SubMenuGroup = 0;
var SubMenuTimers = 1;
var SubMenuSettings = 2;
var SubMenuViews = 3;
var SubMenuPresets = 4;
var SubMenuCapture = 5;
var SubMenuActive = -1;
var SubMenuTimeoutBase = 5;
var SubMenuTimeout = SubMenuTimeoutBase;
var MenuItems = [];

function MakeMenuItem(name, f)
{
	var Item = {};
	Item.name = name
	Item.f = f;
	Item.w = name.length;
	Item.x = 0;
	Item.y = 0;
	return Item;
}
function EnableMenu(m)
{
	if(m != SubMenuActive)
	{
		SubMenuActive = m;
		SubMenuTimeout = SubMenuTimeoutBase;
	}
	if(m == -1)
	{
		SubMenuTimeout = 0;
	}

	if(SubMenuActive == 1)
	{
		FilterInputDiv.style['display'] = 'inline';
		FilterInput.focus();
	}
	else
	{
		FilterInputDiv.style['display'] = 'none';
	}

	console.log("submenuactive " + SubMenuActive + ' timeout ' + SubMenuTimeout);


}
// function ToggleSubMenu(m)
// {
// 	if(m != SubMenuActive)
// 	{
// 		SubMenuActive = m;
// 	}
// 	else
// 	{
// 		SubMenuActive = -1;
// 	}
// 	if(SubMenuActive == 1)
// 	{

// 		var s = TimerMenuSize();
// 		FilterInputDiv.style['display'] = 'inline';
// 		var y = s.y - 40;
// 		FilterInputDiv.style['left'] = s.x + 'px';
// 		FilterInputDiv.style['top'] = y + 'px';
// 		FilterInputDiv.style['right'] = (s.x+s.w) + 'px';
// 		FilterInput.style['width'] = s.w + 'px';
// 		FilterInput.focus();


// 	}
// 	else
// 	{
// 		FilterInputDiv.style['display'] = 'none';
// 	}
// 	console.log("submenuactive " + SubMenuActive);
// }
function Clamp(v, low, high)
{
	return v < low ? low : (v > high ? high : v);
}
function Capture()
{
	var ext = '' + Settings.CaptureFrames;
	if(MouseDragActiveXEnd > MouseDragActiveXStart)
	{
		var idx0 = Math.ceil(FrameCount * MouseDragActiveXStart / nWidth);
		var idx1 = Math.floor(FrameCount * MouseDragActiveXEnd / nWidth);
		idx0 = Clamp(idx0, 0, FrameCount-1);
		idx1 = Clamp(idx1, 0, FrameCount-1);
		var id0 = FrameData.Ids[idx0];
		var id1 = FrameData.Ids[idx1];
		ext = 'r/'+id0+'/'+id1;
	}
	var url = 'http://' + WSHost + ':' + WSPort + '/' + ext;
	alert(url);
	window.open(url);
}
function InitMenu()
{
	MenuItems = [];
	MenuItems.push(MakeMenuItem("Control", function(){EnableMenu(SubMenuGroup); } ));
	MenuItems.push(MakeMenuItem("Timers", function(){EnableMenu(SubMenuTimers); } ));
	MenuItems.push(MakeMenuItem("Settings", function(){ EnableMenu(SubMenuSettings); } ));
	MenuItems.push(MakeMenuItem("Views", function(){ EnableMenu(SubMenuViews); } ));
	MenuItems.push(MakeMenuItem("Presets", function(){ EnableMenu(SubMenuPresets); } ));
}
function DrawTopMenu()
{
	var context = CanvasDetailedView.getContext('2d');
	var X = 2;
	var Y = 0;
	var MouseInY = MouseY < BoxHeight;
	for(var i = 0; i < MenuItems.length; ++i)
	{
		var Item = MenuItems[i];
		var w = context.measureText(Item.name).width + 4;
		var MouseIn = MouseInY && MouseX >= X && MouseX < X + w;
		var color = MouseIn ? nBackColors[1] : "black";
		Item.x = X;
		Item.y = Y + BoxHeight;
		if(MouseIn)
		{
			context.fillStyle = 'white';
			context.fillRect(X-2, Y, w+4, BoxHeight);
			// Enable
			EnableMenu(i);
		}
		context.fillStyle = color;
		context.fillRect(X, Y, w, BoxHeight);
		context.fillStyle = "white";
		context.fillText(Item.name, X+2, Y+BoxHeight-FontAscent);
		if(MouseIn && MouseReleased)
		{
			Item.f();
		}
		X += w + 6;
	}
}

function AggregateMenuSize()
{
	// var Obj = {};
	var w = 250 + 5 + FontWidth;
	// Obj.w = ;
	// Obj.x = ;
	// Obj.y = ;
	return WindowRect(nWidth / 2 - w / 2,HistoryHeight + 50, w, nHeight);
}

function TimerMenuSize()
{
	return MenuSize(WidthArray[TYPE_TIMER] + WidthArray[TYPE_GROUP] + 5 + FontWidth);
}
function GroupMenuSize()
{
	return MenuSize(WidthTree);
}

function MenuSize(w)
{
	return WindowRect(nWidth / 2 - w / 2, HistoryHeight + 50,w, nHeight);
}

function CreateFilter(Filter)
{
	if(!Filter || Filter.length == 0)
	{
		return null;
	}
	Filter = Filter.split(' ');
	for(var i = 0; i < Filter.length; ++i)
	{
		Filter[i] = new RegExp(Filter[i], "i");
	}
	return Filter;
}

function FilterMatch(FilterArray, value)
{
	if(!FilterArray)
		return true;
	for(var i = 0; i < FilterArray.length; ++i)
	{
		var res = value.search(FilterArray[i]);
		if(res<0)
			return false;
	}
	return true;
}


function AddPresets(Names)
{
	for(var i = 0; i < Names.length; ++i)
	{
		if(Presets.indexOf(Names[i]) == -1)
		{
			Presets.push(Names[i]);
		}
	}
}
function EnableByName(name, type)
{
	for(var i = 0;i < TimerArray.length; ++i)
	{
		var t = TimerArray[i];
		if(t.idtype == type && t.name == name)
		{
			WSSendMessage("c" + t.id);
		}
	}
}


function OnLoadPreset(NewSettings)
{
	WSSendMessage("d");
	ActivePreset = NewSettings.PresetName;
	for(var idx in NewSettings)
	{
		console.log(' setting ' + idx + ' to ' + NewSettings[idx]);
		if(idx == 'Timers')
		{
			var Timers = NewSettings[idx];
			for(var i = 0; i < Timers.length; ++i)
			{
				var name = Timers[i];
				EnableByName(name, TYPE_TIMER);
			}
		}
		else if(idx == 'Groups')
		{
			var Groups = NewSettings[idx];
			for(var i = 0; i < Groups.length; ++i)
			{
				var name = Groups[i];
				EnableByName(name, TYPE_GROUP);
			}
		}
		else
		{
			Settings[idx] = NewSettings[idx];
		}
	}
	if(Settings.ViewActive >= 0)
	{
		ActivateView(Settings.ViewActive);
	}
}

function LoadPreset(Name)
{
	Name = Name.replace(",","_");
	WSSendMessage("l"+Name);
}

function SavePreset(Name)
{
	Name = Name.replace(",","_");
	AddPresets([Name]);
	var Timers = [];
	var Groups = [];
	for(var i = 0; i < TimerArray.length; ++i)
	{
		var t = TimerArray[i];
		var idtype = TimerArray[i].idtype;
		if(t.e)
		{
			if(idtype == TYPE_TIMER)
			{
				console.log('adding timer ' + t.name);
				Timers.push(t.name);
			}
			else if(idtype == TYPE_GROUP)
			{
				console.log('adding group ' + t.name);
				Groups.push(t.name);
			}
		}
	}

	Settings.Timers = Timers;
	Settings.Groups = Groups;
	Settings.PresetName = Name;
	var JsonSettings = JSON.stringify(Settings);
	console.log('settings stored ' + JsonSettings);
	WSSendMessage("s"+Name+","+JsonSettings);
	ActivePreset = Name;
}
function DrawMenuPresets()
{
	var Selection = null;
	var SizeInfo = {};
	SizeInfo.h = BoxHeight * (Presets.length * 2 + 1);
	var x = MenuItems[SubMenuPresets].x;
	var y = MenuItems[SubMenuPresets].y;

	var Width = 50;
	var WLeft = MeasureArray(0, ["Save ", "Load ", "Save As .." ]);
	Width = MeasureArray(Width, Presets);
	var Width = 35 + Width + WLeft;
	SizeInfo.w = Width;
	SizeInfo.x = x;
	SizeInfo.y = y;
	
	var M = CreateMenuState(SizeInfo);
	var context = CanvasDetailedView.getContext('2d');
	context.fillRect(M.x, M.y, Width, SizeInfo.h);


	for(var i = 0; i < Presets.length; ++i)
	{
		var Active = ActivePreset == Presets[i] ? 1 : 0;
		if(DrawMenuElement(M, Active, "Load", Presets[i], 'white', 0))
		{
			LoadPreset(Presets[i]);
		}
	}
	DrawMenuElement(M, 0, "---", "", 'white', 0);
	if(DrawMenuElement(M, 0, "Save As..", "", 'white', 0))
	{
		var str = ShowPrompt('Enter Preset Name', '');
		if(str.length>1)
		{
			SavePreset(str);
		}

	}

	for(var i = 0; i < Presets.length; ++i)
	{
		var Active = ActivePreset == Presets[i] ? 1 : 0;
		if(DrawMenuElement(M, Active, "Save", Presets[i], 'white', 0))
		{
			SavePreset(Presets[i]);
		}
	}
	SizeInfo.h = M.y - SizeInfo.y;
	return SizeInfo;

}
function ActivateView(idx)
{
	for(var i = 1; i < Views.length; ++i)
	{
		Views[i].visible = false;
	}
	if(idx == 0)
	{
		MainView.DisplayFunc = DrawGraph;
		MainView.visible = true;
	}
	else if(idx == 1)
	{
		MainView.DisplayFunc = DrawBars;
		MainView.visible = true;
	}
	else if(idx == 2 || idx == 3)
	{
		for(var i = 0; i < X5Views.length; ++i)
		{
			X5Views[i].visible = true;
		}
		SingleTimerBars = idx == 2 ? 0 : 1;
	}
	Settings.ViewActive = idx;
}
function DrawMenuViews()
{
	var ViewClick = function(idx, name)
	{
		ActivateView(idx);
	};
	var x = MenuItems[SubMenuViews].x;
	var y = MenuItems[SubMenuViews].y;
	return DrawMenuGeneric(ViewNames, Settings.ViewActive, ViewClick, x, y);
}

function TweakValue(Value, Tweak, amount, Min, Max)
{
	var V = 0.98;
	if(Tweak<0)
	{
		for(var x = 0; x < Math.abs(Tweak); ++x)
		{
			var newValue = Math.floor(Value*V);
			if(newValue == Value)
			{
				Value--;
			}
			else
			{
				Value = newValue;
			}
		}
	}
	else
	{
		var RcpV = 1.0 / V;

		for(var x = 0; x < Tweak; ++x)
		{
			var newValue = Math.ceil(Value*RcpV);
			if(newValue == Value)
			{
				Value++;
			}
			else
			{
				Value = newValue;
			}
		}
	}
	if(Min && Value < Min)
		Value = Min;
	if(Max && Value > Max)
		Value = Max;
	return Value;

}

function NextValue(Presets, Value, Dir)
{
	var idx = 0;	
	if(Dir > 0)
	{
		for(idx = 0;idx < Presets.length; ++idx)
		{
			if(Presets[idx] > Value)
			{
				break;
			}
		}
	}
	else
	{
		for(idx = Presets.length; idx >= 0; idx -= 1)
		{
			if(Presets[idx] < Value)
			{
				break;
			}
		}
	}
	idx = (idx + Presets.length) % Presets.length;
	return Presets[idx];
}
function AutoCaptureRoll(Direction, Tweak, SetDirect)
{
	if(SetDirect)
	{
		Settings.AutoCaptureTheshold = SetDirect;
	}
	else if(Tweak)
	{
		Settings.AutoCaptureTheshold = TweakValue(Settings.AutoCaptureTheshold, Tweak, 0.98, 1, 500);
	}
	else if(Direction)
	{
		Settings.AutoCaptureTheshold = NextValue(AutoCaptureThesholdPresets, Settings.AutoCaptureTheshold, Direction);
	}
}

function CaptureRoll(Direction, Tweak, SetDirect)
{
	if(SetDirect)
	{
		Settings.CaptureFrames = SetDirect;
	}
	else if(Tweak)
	{
		Settings.CaptureFrames = TweakValue(Settings.CaptureFrames, Tweak, 0.98, 5, 300);

	}
	else if(Direction)
	{
		Settings.CaptureFrames = NextValue(CaptureFramesPresets, Settings.CaptureFrames, Direction);
	}
}
function GetAutoCaptureString()
{
	if(AutoCaptureSourceIndex >= 0)
	{
		if(AutoCaptureSourceIndex >= EnabledArray.length)
		{
			AutoCaptureSourceIndex = -1;
			AutoCaptureSourceIndex = -1;
		}
		else
		{
			var idx = EnabledArray[AutoCaptureSourceIndex];
			return TimerArray[idx].name;
		}
	}
	return "Frame Time";
}

function AutoCaptureSourceRoll(Direction, Tweak, SetDirect)
{
	if(SetDirect)
	{

	}else if(Tweak||Direction)
	{
		if(!Direction)
			Direction = Tweak;
		if(Direction<0)
		{
			AutoCaptureSourceIndex--;
			if(AutoCaptureSourceIndex<-1)
			{
				AutoCaptureSourceIndex = EnabledArray.length-1;
			}
		}
		else
		{
			AutoCaptureSourceIndex++;
			if(AutoCaptureSourceIndex >= EnabledArray.length)
			{
				AutoCaptureSourceIndex = -1;
			}
		}

	}
}

function ShowPrompt(Title, Value, Type)
{
	var v;
	if(Type == 'int')
	{
		var newValue = prompt('' + Title, '' + Value);
		v = parseInt(newValue);
	}
	else if(Type == 'float')
	{
		var newValue = prompt('' + Title, '' + Value);
		v = parseFloat(newValue);
	}
	else
	{
		var v = prompt('' + Title, '' + Value);
		alert('prompt got ' + v);
		return v;
	}
	if(isNaN(v))
	{
		return Value;
	}
	else
	{
		return v;
	}

}
function MeasureArray(v, A, f)
{
	var context = CanvasDetailedView.getContext('2d');	
	for(var i = 0; i < A.length; ++i)
	{
		var s = A[i];
		if(f)
			s=f(s);
		var l = context.measureText(s).width;
		v = v < l ? l : v;
	}
	return v;
}

function CreateMenuState(SizeInfo)
{
	var MenuState = {};
	for(var i in SizeInfo)
	{
		MenuState[i] = SizeInfo[i];
	}
	MenuState.cidx = 0;
	return MenuState;
}

function DrawMenuElement(M, Selected, Name, Value, color)
{
	var context = CanvasDetailedView.getContext('2d');

	var bMouseIn = MouseY >= M.y && MouseY < M.y + BoxHeight;
	var YText = M.y + BoxHeight - FontAscent;

	var bgcolor = bMouseIn ? nBackColorOffset : nBackColors[M.cidx];
	if(Selected)
	{
		context.fillStyle = 'white';
		context.fillRect(M.x-2, M.y, M.w + 4, BoxHeight);
	}
	context.fillStyle = bgcolor;
	context.fillRect(M.x, M.y, M.w, BoxHeight);
	context.fillStyle = color;
	context.fillText(Name, M.x, YText);
	context.textAlign = 'right';
	context.fillText('' + Value, M.x + M.w - 2, YText);
	context.textAlign = 'left';
	M.cidx = 1-M.cidx;
	M.y += BoxHeight;
	return bMouseIn && MouseReleased;
}
function DrawMenuRoll(M, Name, RollValue, RollExt, RollFunction, Tweak, Type)
{
	var context = CanvasDetailedView.getContext('2d');

	var YText = M.y + BoxHeight - FontAscent;
	var SizeMinus = context.measureText('-').width;
	var SizePlus = context.measureText('+').width;

	var bMouseIn = MouseY >= M.y && MouseY < M.y + BoxHeight;
	var bgcolor = bMouseIn ? nBackColorOffset : nBackColors[M.cidx];
	context.fillStyle = bgcolor;
	context.fillRect(M.x, M.y, M.w, BoxHeight);
	context.fillStyle = 'white';
	context.fillText(Name, M.x, YText);
	context.textAlign = 'right';
	var XTemp = M.x + M.w - 3;

	if(KeyShiftDown && bMouseIn)
	{
		if(Tweak>=0)
		{
			RollFunction(0, MouseX-Tweak);
		}
		Tweak = MouseX;
		bMouseIn = false;
	}
	else
	{
		Tweak = -1;
	}

	var MouseReleasedUsed = false;
	if(bMouseIn && MouseX >= XTemp - SizePlus && MouseX <= XTemp)
	{
		context.fillStyle = 'red';
		if(MouseReleased)
		{
			RollFunction(1);
			MouseReleasedUsed = true;
		}
	}
	else
	{
		context.fillStyle = 'white';
	}
	context.fillText('+', XTemp, YText);
	XTemp -= SizePlus + 3;



	if(bMouseIn && MouseX >= XTemp - SizeMinus && MouseX <= XTemp)
	{
		context.fillStyle = 'red';
		if(MouseReleased)
		{
			RollFunction(-1);
			MouseReleasedUsed = true;				
		}
	}
	else
	{
		context.fillStyle = 'white';
	}

	context.fillText('-', XTemp, YText);
	XTemp -= SizeMinus + 3;
	var RollText = ''+RollValue + RollExt;
	var RollWidth = context.measureText(RollText).width;
	context.fillStyle = 'white';

	context.fillText(RollText, XTemp, YText);
	XTemp -= RollWidth;
	
	context.textAlign = 'left';

	M.cidx = 1-M.cidx;

	M.y += BoxHeight;
	//YText += BoxHeight;

	if(Type && MouseReleased && bMouseIn && !MouseReleasedUsed)
	{
		var V = ShowPrompt(Name, RollValue, Type);
		RollFunction(0,0,V);
	}
	return Tweak;

}









function DrawMenuCapture()
{
	var Selection = null;
	var SizeInfo = {};
	SizeInfo.h = 4 * BoxHeight;
	var Strings = ["AutoCapture Enabled", "AutoCapture Threshold", "AutoCapture Source", "Capture Length"];
	var wLeft = MeasureArray(0, Strings);
	var wRight = 50;
	wRight = MeasureArray(wRight, ["Frame Time"]);
	wRight = MeasureArray(wRight, EnabledArray, function(a){return TimerArray[a].name; } );
	var Width = wLeft + 35 + wRight;
	SizeInfo.w = Width;
	SizeInfo.x = CaptureButtonX - SizeInfo.w;
	SizeInfo.y = CaptureButtonY - SizeInfo.h;
	
	var M = CreateMenuState(SizeInfo);
	var context = CanvasDetailedView.getContext('2d');
	context.fillRect(M.x, M.y, Width, SizeInfo.h);
	if(DrawMenuElement(M, 0, "AutoCapture Enabled", AutoCaptureEnabled ? "on" : "off", 'white', 0))
	{
		AutoCaptureEnabled = !AutoCaptureEnabled;
	}
	AutoCaptureSourceTweak = DrawMenuRoll(M, "AutoCapture Source", GetAutoCaptureString(), '', AutoCaptureSourceRoll, AutoCaptureSourceTweak);
	AutoCaptureTweak = DrawMenuRoll(M, "AutoCapture Threshold", Settings.AutoCaptureTheshold, 'ms', AutoCaptureRoll, AutoCaptureTweak, 'int');
	CaptureTweak = DrawMenuRoll(M, "Capture Length",  Settings.CaptureFrames, '', CaptureRoll, CaptureTweak, 'int');

	SizeInfo.h = M.y - SizeInfo.y;
	return SizeInfo;

}
function WindowRect(x,y,w,h)
{
	var s = {};
	s.x = x;
	s.y = y;
	s.w = w;
	s.h = h;
	return s;
}
function GetAggregateString()
{
	if(0 == Settings.AggregateFrames)
		return 'infinite';
	else
		return Settings.AggregateFrames + '';
}

function AggregateRoll(Direction, Tweak, SetDirect)
{
	if(SetDirect)
	{
		Settings.AggregateFrames = SetDirect;
	}
	else if(Tweak)
	{
		Settings.AggregateFrames = TweakValue(Settings.AggregateFrames, Tweak, 0.98, 0, 500);

	}
	else if(Direction)
	{
		Settings.AggregateFrames = NextValue(AggregatePresets, Settings.AggregateFrames, Direction);
	}
}
function ReferenceRoll(Direction, Tweak, SetDirect)
{
	if(SetDirect)
	{
		Settings.ReferenceTime = SetDirect;
	}
	else if(Tweak)
	{
		Settings.ReferenceTime = TweakValue(Settings.ReferenceTime, Tweak, 0.98, 5, 1000);

	}
	else if(Direction)
	{
		Settings.ReferenceTime = NextValue(ReferencePresets, Settings.ReferenceTime, Direction);
	}
}
function TargetRoll(Direction, Tweak, SetDirect)
{
	if(SetDirect)
	{
		Settings.TargetTime = SetDirect;
	}
	else if(Tweak)
	{
		Settings.TargetTime = TweakValue(Settings.TargetTime, Tweak, 0.98, 5, 1000);

	}
	else if(Direction)
	{
		Settings.TargetTime = NextValue(ReferencePresets, Settings.TargetTime, Direction);
	}
}

function DrawMenuSettings()
{
	var context = CanvasDetailedView.getContext('2d');
	var nColorIndex = 0;
	var SizeInfo = AggregateMenuSize();
	SizeInfo.x = MenuItems[SubMenuSettings].x;
	SizeInfo.y = MenuItems[SubMenuSettings].y;

	SizeInfo.w = 200;
	var M = CreateMenuState(SizeInfo);

	AggregateTweak = DrawMenuRoll(M, "Aggregate Frames", GetAggregateString(), '', AggregateRoll, AggregateTweak, 'int');
	ReferenceTimeTweak = DrawMenuRoll(M, "Reference Time", Settings.ReferenceTime, '', ReferenceRoll, ReferenceTimeTweak, 'int');
	TargetTimeTweak = DrawMenuRoll(M, "Target Time", Settings.TargetTime, '', TargetRoll, TargetTimeTweak, 'int');

	SizeInfo.h = M.y - SizeInfo.y;
	return SizeInfo;

}


function MoveFilterInputDiv(x, y, w)
{
	if(FilterInputDivPos.x != x || FilterInputDivPos.y != y || FilterInputDivPos.w != w)
	{
		FilterInputDivPos.x = x;
		FilterInputDivPos.y = y;
		FilterInputDivPos.w = w;
		FilterInputDiv.style['left'] = x + 'px';
		FilterInputDiv.style['top'] = y + 'px';
		FilterInput.style['width'] = w + 'px';
	}
}

function DrawMenuTimer()
{
	var FilterArray = CreateFilter(FilterInput.value);
	var context = CanvasDetailedView.getContext('2d');
	var nColorIndex = 0;
	var SizeInfo = TimerMenuSize();
	SizeInfo.x = MenuItems[SubMenuTimers].x;
	SizeInfo.y = MenuItems[SubMenuTimers].y;
	var Y = SizeInfo.y;
	var Width = SizeInfo.w;
	var Selection = null;
	var X = SizeInfo.x;
	MoveFilterInputDiv(SizeInfo.x, SizeInfo.y, SizeInfo.w);
	Y += 35;//todo: measure somehow?

	for(var i = 0; i < TimerArray.length; ++i)
	{
		var v = TimerArray[i];
		if(v.idtype == TYPE_TIMER)
		{
			var Name = v.name;
			if(FilterMatch(FilterArray, Name))
			{
				var ParentName = TimerArray[v.pidx].name;
				var ParentColor = TimerArray[v.pidx].e ? 'white' : 'grey';
				var bMouseIn = MouseY >= Y && MouseY < Y + BoxHeight;
				var bgcolor = bMouseIn ? nBackColorOffset : nBackColors[nColorIndex];
				var TextY = Y+BoxHeight-FontAscent;
				if(v.e)
				{
					context.fillStyle = 'white';
					context.fillRect(X-2, Y, Width+4, BoxHeight);

				}
				context.fillStyle = bgcolor;
				context.fillRect(X, Y, Width, BoxHeight);
				context.fillStyle = ParentColor;
				context.fillText(ParentName, X + 2, TextY);
				context.fillStyle = v.color;
				context.textAlign = 'right';
				context.fillText(Name, X + Width - 2, TextY);
				context.textAlign = 'left';
				if(bMouseIn)
				{
					Selection = v.id;
				}
				Y += BoxHeight;
				nColorIndex = 1-nColorIndex;
			}
		}
	}
	if(Selection && MouseReleased)
	{
		console.log('pressed on ' + Selection);
		WSSendMessage("c" + Selection);
	}
	SizeInfo.h = Y-SizeInfo.y;
	return SizeInfo;
}
function DrawMenuGeneric(Elements, Active, OnClick, x, y)
{
	var context = CanvasDetailedView.getContext('2d');
	var nColorIndex = 0;

	var h = FontHeight * Elements.length;
	var w = 20;
	for(var i = 0; i < Elements.length; ++i)
	{
		var m = context.measureText(Elements[i]).width;
		w = w > m ? w : m;
	}
	w += 10;
	var SizeInfo = MenuSize(w);
	SizeInfo.x = x;
	SizeInfo.y = y;
	var X = x;
	var Y = y;


	for(var i = 0; i < Elements.length; ++i)
	{
		var Selected = Active == i;
		var Name = Elements[i];
		var bMouseIn = MouseY >= Y && MouseY < Y + BoxHeight;
		var bgcolor = bMouseIn ? nBackColorOffset : nBackColors[nColorIndex];
		var TextY = Y+BoxHeight-FontAscent;
		if(Selected)
		{
			context.fillStyle = 'white';
			context.fillRect(X-2, Y, w+4, BoxHeight);
		}
		context.fillStyle = bgcolor;
		context.fillRect(X, Y, w, BoxHeight);
		context.fillStyle = 'white';
		context.fillText(Name, X + 2, TextY);
		if(bMouseIn && MouseReleased)
		{
			OnClick(i, Name);
		}
		Y += BoxHeight;
		nColorIndex = 1-nColorIndex;
	}
	SizeInfo.h = Y - SizeInfo.y;
	return SizeInfo;
}

function DrawMenuGroup()
{
	var context = CanvasDetailedView.getContext('2d');
	var nColorIndex = 0;
	var Selection = null;
	var SizeInfo = GroupMenuSize();
	SizeInfo.x = MenuItems[SubMenuGroup].x;
	SizeInfo.y = MenuItems[SubMenuGroup].y;
	var Y = SizeInfo.y;
	var X = SizeInfo.x;
	var Width = SizeInfo.w;

	function DrawMenuElement(Selected, Name, color, Indent)
	{
		var bMouseIn = MouseY >= Y && MouseY < Y + BoxHeight;
		var bgcolor = bMouseIn ? nBackColorOffset : nBackColors[nColorIndex];
		if(Selected)
		{
			context.fillStyle = 'white';
			context.fillRect(X-2, Y, Width+4, BoxHeight);
		}
		context.fillStyle = bgcolor;
		context.fillRect(X, Y, Width, BoxHeight);
		context.fillStyle = color;
		if(!Indent) Indent = 0;
		context.fillText(Name, X + Indent*FontWidth, Y+BoxHeight-FontAscent);
		nColorIndex = 1-nColorIndex;
		Y += BoxHeight;
		return bMouseIn;
	}
	function DrawMenuRecursive(Index, Indent)
	{
		ProfileEnter("DrawMenuRecursive");		
		var v = TimerArray[Index];
		if(v.idtype == TYPE_TIMER)
		{
			return;
		}
		var Closed = 0;
		if(Index > 0)
		{
			if(DrawMenuElement(v.e, v.name, v.color, Indent))
			{
				Selection = v.id;
			}
		}

		if(!Closed)
		{
			var ChildIndex = v.firstchild;
			while(ChildIndex)
			{
				DrawMenuRecursive(ChildIndex, Indent + 1);
				ChildIndex = TimerArray[ChildIndex].sibling;
			}
		}
		ProfileLeave();
	}
	DrawMenuRecursive(0, -1);
	if(Selection && MouseReleased)
	{
		console.log('pressed on ' + Selection);
		WSSendMessage("c" + Selection);
	}
	SizeInfo.h = Y - SizeInfo.y;
	return SizeInfo;
}


function DrawMenu()
{
	if(WSConnected && WS && WS.readyState == 1)
	{
		var context = CanvasDetailedView.getContext('2d');
		var nColorIndex = 0;
		var Y = 50;
		var Width = 300;
		var Selection = null;
		ProfileEnter("DrawMenu");
		DrawTopMenu();
		var MenuRect = WindowRect(0,0,nWidth,nHeight);


		if(SubMenuActive == SubMenuGroup)
		{
			MenuRect = DrawMenuGroup();
		}
		else if(SubMenuActive == SubMenuTimers)
		{
			MenuRect = DrawMenuTimer();
		}
		else if(SubMenuActive == SubMenuSettings)
		{
			MenuRect = DrawMenuSettings();
		}
		else if(SubMenuActive == SubMenuViews)
		{
			MenuRect = DrawMenuViews();
		}
		else if(SubMenuActive == SubMenuPresets)
		{
			MenuRect = DrawMenuPresets();
		}
		else if(SubMenuActive == SubMenuCapture)
		{
			MenuRect = DrawMenuCapture();
		}

		var Grow = 10;
		MenuRect.x -= Grow;
		MenuRect.y -= Grow;
		MenuRect.h += 2*Grow;
		MenuRect.w += 2*Grow;
		if(MouseInRect(MenuRect))
		{
			SubMenuTimeout = SubMenuTimeoutBase;
		}
		else
		{
			SubMenuTimeout -= 1;
			console.log('submenutimeout ' + SubMenuTimeout);
			if(SubMenuTimeout <= 0)
			{
				EnableMenu(-1);
			}
		}
		if(1)//debugging of menu extents. dont delete
		{
			context.strokeStyle = 'red';
			context.beginPath();
			context.moveTo(MenuRect.x,MenuRect.y);
			context.lineTo(MenuRect.x + MenuRect.w,MenuRect.y);
			context.lineTo(MenuRect.x + MenuRect.w,MenuRect.y+MenuRect.h);
			context.lineTo(MenuRect.x,MenuRect.y+MenuRect.h);
			context.lineTo(MenuRect.x,MenuRect.y);
			context.stroke();
		}
		ProfileLeave();
	}
}

function DrawConnectionStatus()
{
	if(WSConnected && WS && WS.readyState == 1)
	{
		if(!ProfileMode)
			return;
	}
	var Strings = new Array();
	Strings.push("Status");
	if(WSConnected && WS && WS.readyState == 1)
	{
		Strings.push("[X]");
	}
	else
	{
		ConnectionIdx = (ConnectionIdx + 1 ) % ConnectionStr.length;
		Strings.push("[" + ConnectionStr[ConnectionIdx]+"]");
	}
	Strings.push("Port");
	Strings.push("" + WSPort);
	Strings.push("Path");
	Strings.push("" + WSPath);
	Strings.push("Sends");
	Strings.push("" + WSSend);
	Strings.push("Receives");
	Strings.push("" + WSReceive);
	Strings.push("SendBytes");
	Strings.push("" + WSSendBytes);
	Strings.push("ReceiveBytes");
	Strings.push("" + WSReceiveBytes);
	Strings.push("Seconds");
	Strings.push("" + WSSeconds);
	DrawToolTip(Strings, CanvasDetailedView, 50000, 0);
}
function DrawActiveToolTip()
{
	if(ToolTipCallback)
	{
		var Strings = ToolTipCallback();
		DrawToolTip(Strings, CanvasDetailedView, MouseX, MouseY);
	}
	ToolTipCallback = null;
}
function Draw()
{
	ProfileModeClear();
	ProfileEnter("Total");
	DrawViews();
	
	DrawMenu();
	DrawConnectionStatus();
	DrawPlotf(CanvasDetailedView);
	DrawActiveToolTip();


	ProfileLeave();
	ProfileModeDraw(CanvasDetailedView);

	MouseReleased = false;
}
function RequestDraw()
{
}

function AutoRedraw(Timestamp)
{
	Draw();
	PlotfClear();
	requestAnimationFrame(AutoRedraw);
}




function WSOpen()
{
	SetMessage("Connected!", 1000);
	WSSend = 0;
	WSReceive = 0;
	WSSendBytes = 0;
	WSReceiveBytes = 0;

	TimerArray = [];
	TimerArray.push(Empty);
	WidthArray = [];
	WidthArray[TYPE_NONE] = 0;
	WidthArray[TYPE_TIMER] = 0;
	WidthArray[TYPE_GROUP] = 0;
	WidthArray[TYPE_CATEGORY] = 0;
	WidthTree = FontWidth;

	ResetFrameData();

	console.log('socket is OPEN!! path ' + WSPath);
}

function SplitIdTop(v)
{
	return v >> 24; // todo: verify
}

function SplitIdBottom(v)
{
	return v & 0xffffff; // todo: verify
}

function GetTimer(id)
{
	for(var i = 0; i < TimerArray.length; ++i)
	{
		if(TimerArray[i].id == id)
		{
			return i;
		}
	}
	return null;
}

function UpdateEnabledTimer(idx)
{
	if(TimerArray[idx].idtype != TYPE_TIMER)
	{
		return;
	}
	var enabled = TimerArray[idx].e;
	var AutoCaptureSourceValue = null;
	if(AutoCaptureSourceIndex >= 0 && AutoCaptureSourceIndex < EnabledArray.length)
	{
		AutoCaptureSourceValue = EnabledArray[AutoCaptureSourceIndex];
	}

	var i = EnabledArray.indexOf(idx);
	if(i >= 0)
	{
		EnabledArray.splice(i, 1);
	}
	if(enabled)
	{
		EnabledArray.unshift(idx);
	}
	var NewIndex = AutoCaptureSourceValue != null ? EnabledArray.indexOf(AutoCaptureSourceValue) : -1;
	AutoCaptureSourceIndex = NewIndex;
}


function EnableTimer(T)
{
	var idx = GetTimer(T.id);
	if(idx != null && idx>=0)
	{
		TimerArray[idx].e = T.e;
		UpdateEnabledTimer(idx);
		console.log('tenable ', TimerArray[idx].idtype, " ", TimerArray[idx].idelement, " ", TimerArray[idx].e);
	}
	else
	{
		console.log('unknown enable message');
	}
}
function MeasureWidth(str)
{
	var context = CanvasDetailedView.getContext('2d');
	return context.measureText(str).width;
}
function AddTimer(T)
{
	var idx = TimerArray.length;
	var existing = GetTimer(T.id);
	if(existing)
	{
		idx = existing;
	}
	else
	{
		TimerArray[idx] = T;
	}
	var w = MeasureWidth(T.name);
	var idtype = SplitIdTop(T.id);
	TimerArray[idx].idtype = idtype;
	TimerArray[idx].idelement = SplitIdBottom(T.id);
	TimerArray[idx].w = w;
	TimerArray[idx].wtree = w;
	if(w > WidthArray[idtype])
	{
		WidthArray[idtype] = w;
	}
	
	
	UpdateEnabledTimer(idx);

	var pidx = GetTimer(T.pid);
	if(pidx >= 0 && !existing)
	{
		TimerArray[idx].pidx = pidx;
		var Parent = TimerArray[pidx];
		var Sibling = Parent.firstchild;
		Parent.firstchild = idx;
		if(Sibling)
		{
			if(TimerArray[Sibling].sibling == idx)
			{
				debugger;
			}
		}
		TimerArray[idx].sibling = Sibling;
		TimerArray[idx].wtree += Parent.depth * FontWidth;
		TimerArray[idx].depth = Parent.depth + 1;
		if(TimerArray[idx].wtree > WidthTree)
		{
			WidthTree = TimerArray[idx].wtree;
		}
	}
	console.log('add timer ' + idx + ' parent ' + pidx);
	RequestDraw();

}

function AllocClearedArray(Size)
{
	var A = new Array(Size);
	for(var i = 0; i < Size; ++i)
	{
		A[i] = 0;
	}
	return A;
}
function PushIntoArray(A, v)
{
	A.shift();
	A.push(v);
}
function ResetFrameData()
{
	FrameData = {};
	FrameData.TimerMap = {};
	FrameData.Time = AllocClearedArray(FrameCount);
	FrameData.Ids = AllocClearedArray(FrameCount);
}
function GetFrameData(id)
{
	if(FrameData.TimerMap[id])
	{
		return FrameData.TimerMap[id];
	}
	else
	{
		var FD = {};
		FD.Count = AllocClearedArray(FrameCount);
		FD.Time = AllocClearedArray(FrameCount);
		FD.TimeExcl = AllocClearedArray(FrameCount);
		//Ag
		FD.TimeMax = AllocClearedArray(AggregateHistorySize);
		FD.TimeMin = AllocClearedArray(AggregateHistorySize);
		FD.TimeAvg = AllocClearedArray(AggregateHistorySize);
		FD.TimeExclMax = AllocClearedArray(AggregateHistorySize);
		FD.TimeExclMin = AllocClearedArray(AggregateHistorySize);
		FD.TimeExclAvg = AllocClearedArray(AggregateHistorySize);
		FD.TimeCallAvg = AllocClearedArray(AggregateHistorySize);
		FD.AggregateFrames = 0;
		FD.FrameTime = 0.0;
		FD.Aggregate = 0;
		FD.AggregateTime = 0.0;
		FD.AggregateSum = 0;
		FD.AggregateMax = 0;
		FD.AggregateMin = C_HUGE;
		FD.AggregateExclSum = 0;
		FD.AggregateExclMax = 0;
		FD.AggregateCount = 0;
		FD.AggregateExclMin = C_HUGE;



		FrameData.TimerMap[id] = FD;
		return FD;
	}
}
function SetFrozen()
{
	IsFrozen = 10;
	SetMessage("FROZEN");
}
function ClearFrozen()
{
	if(IsFrozen)
	{
		if(--IsFrozen == 0)
		{
			ClearMessage("FROZEN");
		}

	}

}

function ProcessFrame(F)
{
	var TriggerAutoCapture = 0;
	PushIntoArray(FrameData.Time, F.t);
	PushIntoArray(FrameData.Ids, F.f);
	var CaptureId = null;
	var AutoCapture = AutoCaptureEnabled && !F.wasfrozen;
	if(!F.wasFrozen)
	{
		ClearFrozen();
	}
	else
	{
		SetFrozen();
	}
	if(AutoCapture)
	{
		if(AutoCaptureSourceIndex == -1 && F.t > Settings.AutoCaptureTheshold)
		{
			TriggerAutoCapture = 1;
			console.log('trigger capture! ', F.t, ' ', Settings.AutoCaptureTheshold);
		}
		else if(AutoCaptureSourceIndex >= 0 && AutoCaptureSourceIndex < EnabledArray.length)
		{
			var id = TimerArray[EnabledArray[AutoCaptureSourceIndex]].id;
			var Data = F.x[id];
			if(Data && Data[0])
			{
			 	if(Data[0] > Settings.AutoCaptureTheshold)
			 	{
			 		TriggerAutoCapture = 1;
					console.log('trigger capture! ', Data[0], ' ', Settings.AutoCaptureTheshold);
			 	}
			}
		}
	}


	for(var id in F.x)
	{
		var FD = GetFrameData(id);
		var Data = F.x[id];
		var Time = Data[0];
		var TimeExcl = Data[1];
		var Count = Data[2];
		PushIntoArray(FD.Time, Time);
		PushIntoArray(FD.TimeExcl, TimeExcl);
		PushIntoArray(FD.Count, Count);

		if(FD.Aggregate > Settings.AggregateFrames)
		{
			FD.Aggregate = 0;
			FD.AggregateSum = 0;
			FD.AggregateMax = 0;
			FD.AggregateMin = C_HUGE;
			FD.AggregateExclSum = 0;
			FD.AggregateExclMax = 0;
			FD.AggregateExclMin = C_HUGE;
			FD.AggregateCount = 0;
			
			FD.TimeMax.shift();
			FD.TimeMax.push(0);
			
			FD.TimeMin.shift();
			FD.TimeMin.push(0);

			FD.TimeAvg.shift();
			FD.TimeAvg.push(0);
			
			FD.TimeCallAvg.shift();
			FD.TimeCallAvg.push(0);


			FD.TimeExclMax.shift();
			FD.TimeExclMax.push(0);

			FD.TimeExclMin.shift();
			FD.TimeExclMin.push(0);

			FD.TimeExclAvg.shift();
			FD.TimeExclAvg.push(0);
		}

		FD.Aggregate += 1;
		FD.AggregateSum += Time;
		FD.AggregateMax = FD.AggregateMax > Time ? FD.AggregateMax : Time;
		FD.AggregateMin = FD.AggregateMin < Time ? FD.AggregateMin : Time;
		FD.AggregateExclSum += TimeExcl;
		FD.AggregateExclMax = FD.AggregateExclMax > TimeExcl ? FD.AggregateExclMax : TimeExcl;
		FD.AggregateExclMin = FD.AggregateExclMin < TimeExcl ? FD.AggregateExclMin : TimeExcl;
		FD.AggregateCount += Count;
		var UpdatePos = AggregateHistorySize-1;
		if(UpdatePos != FD.TimeMax.length - 1)
		{
			debugger;
		}

		FD.TimeMax[UpdatePos] = FD.AggregateMax;
		FD.TimeMin[UpdatePos] = FD.AggregateMin;
		FD.TimeAvg[UpdatePos] = FD.AggregateSum / FD.Aggregate;
		FD.TimeCallAvg[UpdatePos] = FD.AggregateSum / FD.AggregateCount;
		FD.TimeExclAvg[UpdatePos] = FD.AggregateExclSum / FD.AggregateCount;
		FD.TimeExclMax[UpdatePos] = FD.AggregateExclMax;
		FD.TimeExclMin[UpdatePos] = FD.AggregateExclMin;
	}

	for(var id in FrameData.TimerMap)
	{
		FD = FrameData.TimerMap[id];
		if(!F.x[id])
		{
			PushIntoArray(FD.Time,0.0);
			PushIntoArray(FD.TimeExcl, 0.0);
			PushIntoArray(FD.Count, 0);
		}
		FD.FrameTime = FD.Time[FD.Time.length-1];
		FD.AggregateTime = FD.Time[FD.Time.length-1];

	}
	FramePending++;


	if(TriggerAutoCapture)
	{
		Capture();
		AutoCaptureEnabled = 0;
	}
}

function WSMessage()
{
	var Obj = JSON.parse(event.data);
	WSReceive++;
	WSReceiveBytes += event.data.length;
	var k = Obj.k;
	if(k == MSG_TIMER_TREE)
	{
		AddTimer(Obj.v);
	}
	else if(k == MSG_ENABLED)
	{
		EnableTimer(Obj.v);
	}
	else if(k == MSG_FRAME)
	{
		ProcessFrame(Obj.v);
	}
	else if(k == MSG_LOADSETTINGS)
	{
		OnLoadPreset(Obj.v);
	}
	else if(k == MSG_PRESETS)
	{
		AddPresets(Obj.v);
	}
}
function WSError()
{
	console.log('WSError');
}
function WSClose()
{
	console.log('WSClose');
}
function WSSendMessage(msgid)
{
	if(WSConnected)
	{
		var str = '' + msgid;
		WSSend++;
		WSSendBytes += str.length;
		WS.send(str);
	}
}


function Connect()
{
	if(WS && (WS.readyState == 1 || WS.readyState == 0))
	{
		WSConnected = WS.readyState == 1;
		WSFail = 0;
		WSSeconds = 0;
	}
	else
	{
		WSConnected = 0;
		WSSeconds = (new Date() - WSOpenTime);
		if(!WS || WSSeconds > 2000)
		{
			if(WS)
			{
				WS.close();
				WS = null;
			}
			WSOpenTime = new Date();
			WSPath = "ws://" + WSHost + ":" + WSPort + "/ws";
			SetMessage('Connecting to ' + WSPath,5 * 1000);
			WS = new WebSocket(WSPath);
			WS.onopen = WSOpen;
			WS.onmessage = WSMessage;
			WS.onerror = WSError;
			WS.onclose = WSClose;
			WSFail = 0;
		}
		else
		{
			WSFail++;
		}
	}
}


function MouseDragPan()
{
	return MouseDragButton == 1 || MouseDragKeyShift;
}
function MouseDragSelectRange()
{
	return MouseDragState == MouseDragMove && (MouseDragButton == 3 || (MouseDragKeyShift || MouseDragKeyCtrl));
}
function MouseHandleDrag()
{
	if(MouseDragTarget == CanvasDetailedView)
	{
		if(MouseDragSelectRange())
		{
			var xStart = MouseDragXStart;
			var xEnd = MouseDragX;
			if(xStart > xEnd)
			{
				var Temp = xStart;
				xStart = xEnd;
				xEnd = Temp;
			}
			if(xEnd - xStart > 1)
			{
				MouseDragActiveXStart = xStart;
				MouseDragActiveXEnd = xEnd;
			}
		}
		else if(MouseDragPan())
		{
		}
		else if(MouseDragKeyCtrl)
		{
		}
	}
}
function MouseHandleDragEnd()
{
	if(MouseDragTarget == CanvasDetailedView)
	{

	}
}

function MouseHandleDragClick()
{

}

function MapMouseButton(Event)
{
	if(event.button == 1 || event.which == 1)
	{
		return 1;
	}
	else if(event.button == 3 || event.which == 3)
	{
		return 3;
	}
	else
	{
		return 0;
	}
}

function MouseDragReset()
{
	MouseDragState = MouseDragOff;
	MouseDragTarget = 0;
	MouseDragKeyShift = 0;
	MouseDragKeyCtrl = 0;
	MouseDragButton = 0;
}
function MouseDragKeyUp()
{
	if((MouseDragKeyShift && !KeyShiftDown) || (MouseDragKeyCtrl && !KeyCtrlDown))
	{
		MouseHandleDragEnd();
		MouseDragReset();
	}
}
function MouseDrag(Source, Event)
{
	if(Source == MouseDragOff || (MouseDragTarget && MouseDragTarget != Event.target))
	{
		MouseDragReset();
		return;
	}

	var LocalRect = Event.target.getBoundingClientRect();
	MouseDragX = Event.clientX - LocalRect.left;
	MouseDragY = Event.clientY - LocalRect.top;
	if(MouseDragState == MouseDragMove)
	{
		var dx = Math.abs(MouseDragX - MouseDragXStart);
		var dy = Math.abs(MouseDragY - MouseDragYStart);
		if((Source == MouseDragUp && MapMouseButton(Event) == MouseDragButton) ||
			(MouseDragKeyCtrl && !KeyCtrlDown) ||
			(MouseDragKeyShift && !KeyShiftDown))
		{
			MouseHandleDragEnd();
			MouseDragReset();
			return;
		}
		else
		{
			MouseHandleDrag();
		}
	}
	else if(MouseDragState == MouseDragOff)
	{
		if(Source == MouseDragDown || KeyShiftDown || KeyCtrlDown)
		{
			MouseDragTarget = Event.target;
			MouseDragButton = MapMouseButton(Event);
			MouseDragState = MouseDragDown;
			MouseDragXStart = MouseDragX;
			MouseDragYStart = MouseDragY;
			MouseDragKeyCtrl = 0;
			MouseDragKeyShift = 0;

			if(KeyShiftDown || KeyCtrlDown)
			{
				MouseDragKeyShift = KeyShiftDown;
				MouseDragKeyCtrl = KeyCtrlDown;
				MouseDragState = MouseDragMove;
			}
		}
	}
	else if(MouseDragState == MouseDragDown)
	{
		if(Source == MouseDragUp)
		{
			MouseHandleDragClick();
			MouseDragReset();
		}
		else if(Source == MouseDragMove)
		{
			var dx = Math.abs(MouseDragX - MouseDragXStart);
			var dy = Math.abs(MouseDragY - MouseDragYStart);
			if(dx+dy>1)
			{
				MouseDragState = MouseDragMove;
			}
		}
	}
	MouseDragXLast = MouseDragX;
	MouseDragYLast = MouseDragY;
}



function MouseMove(evt)
{
    evt.preventDefault();
	var rect = evt.target.getBoundingClientRect();
	var x = evt.clientX - rect.left;
	var y = evt.clientY - rect.top;
	MouseX = x;
	MouseY = y;


    MouseDrag(MouseDragMove, evt);



}

function MouseButton(bPressed, evt)
{
    evt.preventDefault();
    MouseReleased = !bPressed;
	MouseDrag(bPressed ? MouseDragDown : MouseDragUp, evt);


	// MouseDrag(bPressed ? MouseDragDown : MouseDragUp, evt);
	// if(!bPressed)
	// {
	// 	if(SortColumnMouseOverNext)
	// 	{
	// 		if(SortColumnMouseOverNext == SortColumnMouseOver)
	// 		{
	// 			SortColumnOrderFlip =  1 - SortColumnOrderFlip;
	// 		}
	// 		else
	// 		{
	// 			SortColumnOrderFlip = 0;
	// 		}

	// 		SortColumnMouseOver = SortColumnMouseOverNext;
	// 		SortColumnMouseOverNext = null;
	// 		if(SortColumnMouseOver == StrAverage)
	// 		{
	// 			SortColumn = 1;
	// 		}
	// 		else if(SortColumnMouseOver == StrMax)
	// 		{
	// 			SortColumn = 2;
	// 		}
	// 		else if(SortColumnMouseOver == StrTotal)
	// 		{
	// 			SortColumn = 3;
	// 		}			
	// 		else if(SortColumnMouseOver == StrMin)
	// 		{
	// 			SortColumn = 4;
	// 		}
	// 		else if(SortColumnMouseOver == StrSpike)
	// 		{
	// 			SortColumn = 5;
	// 		}
	// 		else if(SortColumnMouseOver == StrCallAverage)
	// 		{
	// 			SortColumn = 6;
	// 		}
	// 		else if(SortColumnMouseOver == StrCount)
	// 		{
	// 			SortColumn = 7;
	// 		}
	// 		else if(SortColumnMouseOver == StrExclAverage)
	// 		{
	// 			SortColumn = 8;
	// 		}
	// 		else if(SortColumnMouseOver == StrExclMax)
	// 		{
	// 			SortColumn = 9;
	// 		}
	// 		else if(SortColumnMouseOver == StrGroup)
	// 		{
	// 			SortColumn = 0;
	// 		}
	// 		RequestRedraw();
	// 	}
	// }
}

function MouseOut(evt)
{
	MouseDrag(MouseDragOff, evt);
	// KeyCtrlDown = 0;
	KeyShiftDown = 0;
	// MouseDragButton = 0;
	// nHoverToken = -1;
	// RangeCpu = RangeInit();
}

function MouseWheel(e)
{
//     var e = window.event || e;
//     var delta = (e.wheelDelta || e.detail * (-120));
//     ZoomGraph((-4 * delta / 120.0) | 0);
//     Draw(1);
}

function KeyUp(evt)
{
	var k = evt.keyCode;
	console.log('keyup ' + k);
	if(k == 220)
	{
		ProfileMode = !ProfileMode;
	}
	if(k == 27)
	{
		if(FilterInput.value.trim() != "")
		{
			FilterInput.value = "";
		}
		else
		{
			EnableMenu(-1);
		}

		MouseDragActiveXStart = MouseDragActiveXEnd = -1;
	}
	if(k == 191)
	{
		WSPort++;
		if(WSPort > 1338+2)
		{
			WSPort = 1338;
		}
		if(WS)
		{
			WS.close();
			WS = null;
		}
	}
	if(k == 32)
	{
		SetFrozen();
		WSSendMessage("f");
	}
	if(k == 13)
	{
		Capture();
	}
	if(evt.keyCode == 17)
	{
		KeyCtrlDown = 0;
		MouseDragKeyUp();
	}
	if(evt.keyCode == 16)
	{
		KeyShiftDown = 0;
		MouseDragKeyUp();
	}

}

function KeyDown(evt)
{
	if(evt.keyCode == 17)
	{
		KeyCtrlDown = 1;
		MouseDragKeyUp();
	}
	if(evt.keyCode == 16)
	{
		KeyShiftDown = 1;
		MouseDragKeyUp();
	}
}


function SetupEvents()
{
	var mousewheelevt = (/Firefox/i.test(navigator.userAgent)) ? "DOMMouseScroll" : "mousewheel" //FF doesn't recognize mousewheel as of 
	CanvasDetailedView.addEventListener('mousemove', MouseMove, false);
	CanvasDetailedView.addEventListener('mousedown', function(evt) { MouseButton(true, evt); });
	CanvasDetailedView.addEventListener('mouseup', function(evt) { MouseButton(false, evt); } );
	CanvasDetailedView.addEventListener('mouseout', MouseOut);
	CanvasDetailedView.addEventListener("contextmenu", function (e) { e.preventDefault(); }, false);
	CanvasDetailedView.addEventListener(mousewheelevt, MouseWheel, false);
	window.addEventListener('keydown', KeyDown);
	window.addEventListener('keyup', KeyUp);
	window.addEventListener('resize', ResizeCanvas, false);
}

function DrawToolTip(StringArray, Canvas, x, y)
{
	var context = Canvas.getContext('2d');
	context.font = Font;
	var WidthArray = Array(StringArray.length);
	var nMaxWidth = 0;
	var nHeight = 0;
	for(var i = 0; i < StringArray.length; i += 2)
	{
		var nWidth0 = context.measureText(StringArray[i]).width;
		var nWidth1 = context.measureText(StringArray[i+1]).width;
		var nSum = nWidth0 + nWidth1;
		WidthArray[i] = nWidth0;
		WidthArray[i+1] = nWidth1;
		if(nSum > nMaxWidth)
		{
			nMaxWidth = nSum;
		}
		nHeight += BoxHeight;
	}
	nMaxWidth += 15;
	//bounds check.
	var CanvasRect = Canvas.getBoundingClientRect();
	if(y + nHeight > CanvasRect.height)
	{
		y = CanvasRect.height - nHeight;
		x += 20;
	}
	if(x + nMaxWidth > CanvasRect.width)
	{
		x = CanvasRect.width - nMaxWidth;
	}

	context.fillStyle = 'black';
	context.fillRect(x-1, y, nMaxWidth+2, nHeight);
	context.fillStyle = 'white';

	var XPos = x;
	var XPosRight = x + nMaxWidth;
	var YPos = y + BoxHeight-2;
	for(i = 0; i < StringArray.length; i += 2)
	{
		context.fillText(StringArray[i], XPos, YPos);
		context.fillText(StringArray[i+1], XPosRight - WidthArray[i+1], YPos);
		YPos += BoxHeight;
	}
}

function DrawPlotf(Canvas)
{
	return;
	var context = Canvas.getContext('2d');
	context.font = Font;
	var WidthArray = Array(PlotfArray.length);
	var nMaxWidth = 0;
	var nHeight = 0;

	context.font = Font;
	for(i = 0; i < PlotfArray.length; i++)
	{
		var nWidth = context.measureText(PlotfArray[i]).width;
		WidthArray[i] = nWidth;
		if(nWidth > nMaxWidth)
		{
			nMaxWidth = nWidth;
		}
		nHeight += BoxHeight;
	}
	nMaxWidth += 15;
	var x = 0;
	var y = 0;

	context.fillStyle = 'black';
	context.fillRect(x-1, y, nMaxWidth+2, nHeight);
	context.fillStyle = 'white';

	var XPos = x;
	var XPosRight = x + nMaxWidth;
	var YPos = y + BoxHeight-2;
	for(i = 0; i < PlotfArray.length; i++)
	{
		context.fillText(PlotfArray[i], XPos, YPos);
		YPos += BoxHeight;
	}
}




ResizeCanvas();
SetupEvents();
InitMenu();

setInterval(Connect, 10);
// window.alert(' host is ' + location.hostname + ' port ' + location.port);


//Draw();
AutoRedraw();





</script>


</body>
</html>      


